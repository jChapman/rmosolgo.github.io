
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Persisted GraphQL Queries with Ruby - Robert Mosolgo</title>
  <meta name="author" content="Robert Mosolgo">

  
  <meta name="description" content="GraphQL Pro 1.3.0 adds support for server-defined queries via GraphQL::Pro::Repository. In this approach, GraphQL operations are stored on the server &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://rmosolgo.github.io/blog/2017/03/07/persisted-graphql-queries-with-ruby">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="http://feeds.feedburner.com/RobertMosolgo" rel="alternate" title="Robert Mosolgo" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Gentium+Book+Basic' rel='stylesheet' type='text/css'>

  

</head>

<body   class="no-sidebar"  >
  <div id="wrapper">
    <header role="banner"><hgroup>
  <h1 class="site-title">
  	<a href="/">Robert Mosolgo</a>
  </h1>
  
</hgroup>

</header>
    <nav role="navigation"><ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/about">About</a></li>
  <li><a href="/blog/archives">Blog</a></li>
  <li><a href="/talks">Talks</a></li>
  <li><a href="http://feeds.feedburner.com/RobertMosolgo" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
</ul>

</nav>
    <div id="main">
      <div id="content">
        <div>
<article class="hentry" role="article">
  

  
  <header>
    
      <h1 class="entry-title">Persisted GraphQL Queries With Ruby</h1>
    
    
      <p class="meta">
        








  


<time datetime="2017-03-07T07:55:00-05:00" pubdate data-updated="true">Mar 7<span>th</span>, 2017</time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://graphql.pro" target="_blank">GraphQL Pro</a> 1.3.0 adds <a href="http://rmosolgo.github.io/graphql-ruby/pro/persisted_queries">support for server-defined queries via <code>GraphQL::Pro::Repository</code></a>. In this approach, GraphQL operations are stored on the server and clients invoke them by name.</p>

<!-- more -->


<p>This provides several benefits:</p>

<ul>
<li>You can completely close the door to client-provided query strings. This removes an attack vector for a malicious client who might try to swamp your system with expensive queries.</li>
<li>Static queries (in <code>.graphql</code> files) are easier to review and more available tooling (eg, code generation or analysis).</li>
<li>Operation names improve <a href="http://rmosolgo.github.io/graphql-ruby/pro/monitoring">GraphQL server monitoring</a> by serving as the primary unit of analysis.</li>
</ul>


<h2>What&rsquo;s a &ldquo;repository?&rdquo;</h2>

<p>A <code>GraphQL::Pro::Repository</code> works like a single, large GraphQL document with many different operations (ie, queries, mutations, or subscriptions) and fragments inside it. These operations are validated and analyzed as a single unit, as if they came in a single query string.</p>

<p>From a client&rsquo;s perspective, the server has a fixed set of operations it can perform. Each one can be executed by sending its <a href="http://graphql.org/learn/queries/#operation-name">operation name</a>.</p>

<p>The repository approach allows us to use pre-existing GraphQL concepts:</p>

<ul>
<li><strong><a href="https://facebook.github.io/graphql/#sec-Language.Query-Document">Document</a></strong>: A GraphQL document is a set of operations and fragments. The semantics of a valid document are <a href="https://facebook.github.io/graphql/#sec-Validation">well-specified</a> and broadly implemented. A repository is an extension of this concept.</li>
<li><a href="http://graphql.org/learn/queries/#operation-name"><strong>Operation name</strong></a>: GraphQL includes a way to specify which operation to run in a document. Repositories build on this by separating the set of operations (which lives on the server) from the identifier (which comes from the client).</li>
</ul>


<p>By employing these concepts, we make full use of the battle-tested <a href="https://github.com/rmosolgo/graphql-ruby">graphql-ruby</a> runtime without deviating from the spec.</p>

<h2>A Quick Example</h2>

<p>First, add a <code>.graphql</code> file with a named operation:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'># app/graphql/documents/GetItems.graphql
</span><span class='line'>query GetItems {
</span><span class='line'>  # Your GraphQL here:
</span><span class='line'>  items {
</span><span class='line'>    name
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>Then, define a repository with that path:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">MyAppRepository</span> <span class="o">=</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Pro</span><span class="o">::</span><span class="no">Repository</span><span class="o">.</span><span class="n">define</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">schema</span> <span class="no">MyAppSchema</span>
</span><span class='line'>  <span class="n">path</span> <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;app/graphql/documents&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Next, update your controller to execute queries with the repository instead of the schema:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='diff'><span class='line'># app/controllers/graphql_controller.rb
</span><span class='line'><span class="gd">- MyAppSchema.execute(</span>
</span><span class='line'><span class="gd">-   query_string,</span>
</span><span class='line'><span class="gi">+ MyAppRepository.execute(</span>
</span><span class='line'><span class="gi">+   operation_name: params[:operationName]</span>
</span><span class='line'>    context: context,
</span><span class='line'>    variables: variables,
</span><span class='line'>  )
</span></code></pre></td></tr></table></div></figure>


<p>Finally, execute the operation by sending a request with the <code>operationName</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">$</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s2">&quot;/graphql&quot;</span><span class="p">,</span> <span class="p">{</span> <span class="nx">operationName</span><span class="o">:</span> <span class="s2">&quot;GetItems&quot;</span> <span class="p">},</span> <span class="kd">function</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">data</span><span class="p">)</span>
</span><span class='line'><span class="p">})</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// {</span>
</span><span class='line'><span class="c1">//   items: [</span>
</span><span class='line'><span class="c1">//     { name: &quot;Item 1&quot; },</span>
</span><span class='line'><span class="c1">//     ...</span>
</span><span class='line'><span class="c1">//    ]</span>
</span><span class='line'><span class="c1">// }</span>
</span></code></pre></td></tr></table></div></figure>


<p>🎉 We served a GraphQL response by name!</p>

<h2>Naming Files</h2>

<p>A straightforward approach is to name <code>.graphql</code> files after the operations they contain, so this operation:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>mutation UpdateComment($id: Int!, $body: String!) {
</span><span class='line'>  updateComment(id: $id, body: $body) {
</span><span class='line'>    # ...
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>would go in:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>app/graphql/documents/UpdateComment.graphql
</span></code></pre></td></tr></table></div></figure>


<p>This way, a reader can skim the <code>app/graphql/documents</code> directory to take a quick inventory of operations. Also, this one-to-one mapping mimics the Ruby convention of putting constants in identically-named files.</p>

<p>In the end, <code>GraphQL::Pro::Repository</code> will accept files with any name, as long as they match <code>#{path}/**/*.graphql</code>.</p>

<h2>Sharing Fragments</h2>

<p>Since a repository functions as one big GraphQL document, <a href="http://graphql.org/learn/queries/#fragments">fragments</a> are shared by default.</p>

<p>You can put fragments in their own files, then reference them from each operation that needs them. This way, operations with common data responsibilities can share code, ensuring that they stay in sync.</p>

<p>For example, consider a list of comments with a box to create a new comment. We&rsquo;d make three <code>.graphql</code> files:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>app/graphql/documents/
</span><span class='line'>  ListComments.graphql
</span><span class='line'>  CreateComment.graphql
</span><span class='line'>  CommentFields.graphql
</span></code></pre></td></tr></table></div></figure>


<p>First, specify the operation to load the list of comments:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'># app/graphql/documents/ListComments.graphql
</span><span class='line'>query ListComments($postId: ID!) {
</span><span class='line'>  post(id: $id) {
</span><span class='line'>    comments {
</span><span class='line'>      author {
</span><span class='line'>        name
</span><span class='line'>      }
</span><span class='line'>      body
</span><span class='line'>      createdAt
</span><span class='line'>      updatedAt
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>Then, specify the operation to create a new comment:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'># app/graphql/documents/CreateComment.graphql
</span><span class='line'>query CreateComment($postId: ID!, $body: String!) {
</span><span class='line'>  createComment(postId: $postId, body: $body) {
</span><span class='line'>    # ??
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>After creating a comment, you want to update the list of comments to include the new member. To express this shared need for data, create a fragment with the required fields:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'># app/graphql/documents/CommentFields.graphql
</span><span class='line'>fragment CommentFields on Comment {
</span><span class='line'>  author {
</span><span class='line'>    name
</span><span class='line'>  }
</span><span class='line'>  body
</span><span class='line'>  createdAt
</span><span class='line'>  updatedAt
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>Then, apply the fragment to <code>ListComments</code> and <code>CreateComment</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='diff'><span class='line'># app/graphql/documents/ListComments.graphql
</span><span class='line'>  query ListComments($postId: ID!) {
</span><span class='line'>    post(id: $id) {
</span><span class='line'>      comments {
</span><span class='line'><span class="gi">+       ...CommentFields</span>
</span><span class='line'><span class="gd">-       author {</span>
</span><span class='line'><span class="gd">-         name</span>
</span><span class='line'><span class="gd">-       }</span>
</span><span class='line'><span class="gd">-       body</span>
</span><span class='line'><span class="gd">-       createdAt</span>
</span><span class='line'><span class="gd">-       updatedAt</span>
</span><span class='line'>      }
</span><span class='line'>    }
</span><span class='line'>  }
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='diff'><span class='line'>  # app/graphql/documents/CreateComment.graphql
</span><span class='line'>  query CreateComment($postId: ID!, $body: String!) {
</span><span class='line'>    createComment(postId: $postId, body: $body) {
</span><span class='line'><span class="gd">-     # ??</span>
</span><span class='line'><span class="gi">+     ...CommentFields</span>
</span><span class='line'>    }
</span><span class='line'>  }
</span></code></pre></td></tr></table></div></figure>


<p>This way:</p>

<ul>
<li>A reader can see that these operations are linked</li>
<li>If the list view ever requires more data, the create operation will load that data, too</li>
</ul>


<h2>Next Steps</h2>

<ul>
<li>Repositories can also <a href="http://rmosolgo.github.io/graphql-ruby/pro/persisted_queries#arbitrary-input">accept dynamic inputs</a>. This allows you to use GraphiQL during development or continue serving old clients while you transition to server-defined queries.</li>
<li>On Rails, repositories watch their files and reload as needed. If you&rsquo;re using another framework, you can <a href="http://rmosolgo.github.io/graphql-ruby/pro/persisted_queries#watching-files">reload repositories</a> as needed.</li>
<li>You can use a repository to find <a href="http://rmosolgo.github.io/graphql-ruby/pro/persisted_queries#analysis">unused fields</a> in your schema.</li>
</ul>


<p>For me, I&rsquo;m hoping to improve client support (eg, Apollo Client) and server tooling (eg, query diffing) to make repositories even more useful!</p>
</div>


  <footer>
    <p class="meta" style="color: #999999;">
      
  

<span class="byline author vcard">Posted by <span class="fn">Robert Mosolgo</span></span>

      








  


<time datetime="2017-03-07T07:55:00-05:00" pubdate data-updated="true">Mar 7<span>th</span>, 2017</time>
      

in
<span class="categories">
  
    <a class='category' href='/blog/categories/graphql/'>GraphQL</a>, <a class='category' href='/blog/categories/ruby/'>Ruby</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <div class="other-posts">
      
        <div class="prev-post">
          <a href="/blog/2017/01/22/parallelism-in-graphql-ruby/" title="Previous Post: Parallelism in GraphQL-Ruby">&laquo; Parallelism in GraphQL-Ruby</a>
        </div>
      
      
        <div class="next-post">
          <a href="/blog/2017/03/08/optimizing-graphql-ruby/" title="Next Post: Optimizing GraphQL-Ruby">Optimizing GraphQL-Ruby &raquo;</a>
        </div>
      
    </p>
  </footer>
</article>
</div>


      </div>
    </div>
    <footer role="contentinfo"><p>
  Copyright &copy; 2018 Robert Mosolgo
</p>

</footer>
    











  </div>
</body>
</html>
