<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Robert Mosolgo]]></title>
  <link href="http://rmosolgo.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://rmosolgo.github.io/"/>
  <updated>2017-10-05T13:05:16-04:00</updated>
  <id>http://rmosolgo.github.io/</id>
  <author>
    <name><![CDATA[Robert Mosolgo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Raising Exceptions is Bad]]></title>
    <link href="http://rmosolgo.github.io/blog/2016/11/23/raising-exceptions-is-bad/"/>
    <updated>2016-11-23T10:34:00-05:00</updated>
    <id>http://rmosolgo.github.io/blog/2016/11/23/raising-exceptions-is-bad</id>
    <content type="html"><![CDATA[<p>In general, <a href="http://wiki.c2.com/?DontUseExceptionsForFlowControl">raising exceptions for control flow</a> makes code hard to understand. However, there are other cases when an exception is the right choice.</p>

<!-- more -->


<h2>Raise vs Return</h2>

<p><code>raise</code> is <code>return</code>&rsquo;s evil twin.</p>

<p>They <strong>both</strong> stop the execution of the current method. After a <code>return</code>, nothing else is executed. After a <code>raise</code>, nothing else is executed &hellip; <em>maybe</em>. The method may have a <code>rescue</code> or <code>ensure</code> clause which is executed after the <code>raise</code>, so a reader must check for those.</p>

<p>They <strong>both</strong> change flow of control. <code>return</code> gives control back to the caller. <code>raise</code> may give control <em>anywhere</em> on the call stack, depending on the specific error and <code>rescue</code> clauses. If all you see is a <code>raise</code>, you can&rsquo;t guess where it will be rescued!</p>

<p>They <strong>both</strong> send values to their new destination. <code>return</code> provides the given value to the caller, who may capture the return value in a local variable. <code>raise</code> provides the error object to the <code>rescue</code>-er. <code>return</code> can send any kind of value, but <code>raise</code> can only send error objects.</p>

<p>They <strong>both</strong> create coupling across call stack frames. <code>return</code> couples two adjacent call stack frames: caller depends on the return value. <code>raise</code> ‚Üí <code>rescue</code> couples far-removed stack frames: they may be adjacent, or they may be several frames removed from one another.</p>

<h2>Raise ‚Üí Rescue is Unpredictable</h2>

<p>Sending values through a program by calling methods and <code>return</code>-ing values is very predictable. If you return a different value, the caller will get a different value. To see where return values &ldquo;go&rdquo;, simply search for calls to that method.</p>

<p>Finding where <code>raise</code>&rsquo;d errors go is a bit more challenging. For example, this change:</p>

<pre><code class="ruby"># From:
def do_something
  # ...
  raise "Something went wrong"
end

# To:
class MyCustomError &lt; StandardError
end

def do_something
  # ...
  raise MyCustomError, "Oops!"
end
</code></pre>

<p>How can you tell if this is a safe refactor? Here are some considerations:</p>

<ul>
<li>Instead of looking for callers of this method, you have to find <em>entire call stacks</em> which include this method, since any upstream calls may also have expectations about this error.</li>
<li>When searching for <code>rescue</code>s, you have to keep the error&rsquo;s ancestry in mind, finding bare <code>rescue</code>s, superclass-tagged <code>rescue</code>s and class-tagged <code>rescue</code>s.</li>
<li>Some <code>rescue</code>s may <em>consume</em> the error object itself. For example, they may read its <code>#message</code> or other attached data. If you change any properties of the error object, you may break the assumptions of those <code>rescue</code>s.</li>
<li>If you find that the new error will be <code>rescue</code>&rsquo;d differently, you must also consider how execution flow will change in other methods. For example, some methods may be cut short because previously-<code>rescue</code>&rsquo;d errors now propagate through them. Other methods which <em>used</em> to be cut short may now continue running, since errors are rescued in child method calls.</li>
</ul>


<p>If your <code>raise</code> is located in a Ruby gem, these problems are even harder, because <code>rescue</code> clauses may exist in your users' code.</p>

<p>If your error patterns are well documented, <code>‡ºº „Å§ ‚óï_‚óï ‡ºΩ„Å§ üèÜ</code>. Bravo, just don&rsquo;t break your public API. Users might still make assumptions <em>beyond</em> the documentation, such as error ancestry or message values. Additionally, they could be monkey-patching library methods and applying <code>rescue</code>-related assumptions to those patches.</p>

<p>If your error patterns aren&rsquo;t documented, <code>üí© „Éé‡ºº ‚óï_‚óï „Éé ‡ºΩ</code>. You have no idea what assumptions users make about those errors! You can&rsquo;t be sure your changes won&rsquo;t break their code.</p>

<h2>Use Return Instead</h2>

<p><code>raise</code> can be replaced by <code>return</code>. However, if you&rsquo;re using <code>raise</code> to traverse many levels of the call stack, the refactor will be intense. Take heart: previously you were hacking your way back up the call stack, now you&rsquo;re creating a predictable, explicit flow through your program!</p>

<p>It&rsquo;s worth repeating, <a href="http://wiki.c2.com/?DontUseExceptionsForFlowControl">don&rsquo;t use exceptions for flow control</a>.</p>

<p>Here are some techniques for expressing failures with <code>return</code>.</p>

<ul>
<li><strong>Return errors</strong> instead of raising them. Ruby errors are objects, like everything else. You can return them to the caller and let the caller check whether the returned value is an error or not.  For example, to return an error:</li>
</ul>


<pre><code class="ruby">def do_something
  calculation = SomeCalculation.new # ...

  if calculation.something_went_wrong?  
    # Let the caller handle this error
    MyCustomError.new("oops!")
  else
    # Return the result to the caller
    calculation.result
  end
end
</code></pre>

<ul>
<li><strong>Use success and failure objects</strong>. Instead of returning a raw <code>StandardError</code> instance to the caller, use a <code>Failure</code> class to communicate failure. Additionally, use a <code>Success</code> class to communicate success. (This is similar to the &ldquo;monad&rdquo; technique, eg <a href="http://dry-rb.org/gems/dry-monads/"><code>dry-monads</code> gem</a>.)</li>
</ul>


<pre><code class="ruby">class ConvertSuccess
  attr_reader :old_file, :new_file
  def initialize(old_file:, new_file:)
    # ...
  end
end

class ConvertFailure
  attr_reader :old_file, :error
  def initialize(old_file:, error:)
    # ...
  end
end

# Try to convert this file, returning either a
# ConvertSuccess or ConvertFailure)
def convert_file(file)
  # ...
  if error_message.nil?
    ConvertSuccess.new(old_file: file, new_file: converted_file)
  else
    ConvertFailure.new(old_file: file, error: error_message)
  end
end

# Try to convert a file,
# then specify behavior
# for failure case &amp; success case:
conversion = convert_file(File.read(file_path))

case conversion
when ConvertSuccess
  # Do something with the new file
when ConvertFailure
  # Notify the user of the failure
end   
</code></pre>

<ul>
<li><p>As a last resort, <strong>return <code>nil</code></strong>. Using <code>nil</code> as an expression of failure has some downsides:</p>

<ul>
<li><code>nil</code> can&rsquo;t hold a message or any extra data</li>
<li>sometimes, <code>nil</code> is a valid value</li>
</ul>


<p>But, for simple operations, using <code>nil</code> may be sufficient. Since it will be communicated via <code>return</code>, refactoring it will be straightforward in the future!</p></li>
</ul>


<h2>Sometimes, Raise is Okay</h2>

<p><code>raise</code> has its purposes.</p>

<p><code>raise</code> is a great way to signal that the program has reached a completely unexpected state and that it should exit. For example, in the <code>convert_file</code> example above, we could use <code>raise</code> to assert that we don&rsquo;t receive an unexpected value from <code>convert_file</code>:</p>

<pre><code class="ruby">conversion = convert_file(File.read(file_path))
case conversion
when ConvertSuccess
  # Do something with the new file
when ConvertFailure
  # Notify the user of the failure
else
  raise("convert_file didn't return a ConvertSuccess or ConvertFailure, it returned: #{conversion.inspect}")
end   
</code></pre>

<p>Now, if the method ever returns some unexpected value, we&rsquo;ll receive a loud failure. Some people use <code>fail</code> in this case, which is also fine. However, the need to disambiguate <code>raise</code> and <code>fail</code> is a code smell: stop using <code>raise</code> for non-emergencies!</p>

<p><code>raise</code> is also helpful for re-raising other errors. For example, if your library needs to log something when an error happens, it might need to capture the error, then re-raise it. For example:</p>

<pre><code class="ruby"># This method yields to a user-provided block, eg
# `handle_converted_file(old_file) { |f| push_to_s3(f) }`
def handle_converted_file(old_file)
  conversion = convert_file(old_file)
  if conversion.is_a?(ConvertSuccess)
    yield(conversion.new_file)
  end
rescue StandardError =&gt; err
  # Make a log entry for the library:
  logger.log("User error from handle_converted_file", err)
  # Let the user handle this error:
  raise(err)
end
</code></pre>

<p>This way, you can respond to the error without disrupting user code.</p>

<h2>raise SharpKnifeError</h2>

<p>In my own work, I&rsquo;m transitioning <em>away</em> from raising errors and <em>towards</em> communicating failure by return values. This pattern is ubiquitous in languages like Go and Elixir. In Node.js, callbacks communicate errors in a similar way (callback arguments). I think Ruby code can benefit from this practice as well.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Class, meet Elixir Module]]></title>
    <link href="http://rmosolgo.github.io/blog/2016/05/01/ruby-class-meet-elixir-module/"/>
    <updated>2016-05-01T11:10:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2016/05/01/ruby-class-meet-elixir-module</id>
    <content type="html"><![CDATA[<p>Elixir modules offer some valuable insight into designing Ruby classes.</p>

<!-- more -->


<p>Ruby classes combine <em>data</em> and <em>behavior</em> in a typically object-oriented way:</p>

<ul>
<li><strong>data:</strong> instances of the class hold state in instance variables</li>
<li><strong>behavior:</strong> methods on the class alter state.</li>
</ul>


<p>Elixir modules also combine data and behavior:</p>

<ul>
<li><strong>data:</strong> the module&rsquo;s eponymous struct defines an immutable data structure</li>
<li><strong>behavior:</strong> the module&rsquo;s functions define state transformations, often taking the struct as input</li>
</ul>


<p>Perhaps we can combine these ideas to gain some functional-style benefits in Ruby!</p>

<h2>Data: Problem</h2>

<p>Ruby&rsquo;s mutable values open the door to errors caused by out-of-sight state changes. Here&rsquo;s a simple example:</p>

<pre><code class="ruby"># mutate the passed-in array üòà
def cause_mayhem(array)
  array &lt;&lt; nil
end

top_scores = [98, 95, 89]
cause_mayhem(top_scores)
top_scores.max # ArgumentError: comparison of Fixnum with nil failed
</code></pre>

<p>Unbeknownst to the user, <code>cause_mayhem</code> <em>altered</em> the array. It wasn&rsquo;t equal to its original value anymore! This is possible with many common objects in Ruby programming , eg <code>String</code>, <code>Hash</code>, <code>ActiveRecord::Base</code>, <code>ActiveRecord::Relation</code> and <code>ActionController::Params</code>.</p>

<p>When you pass a value to another method, you have <em>no way</em> to know how your value will be affected. Maybe it will be changed under your feet!</p>

<p>Elixir&rsquo;s immutable values offer a solution to this pitfall. When you pass a value to a function, your value won&rsquo;t be changed because it&rsquo;s <em>impossible</em> to change it!</p>

<pre><code class="elixir">cause_mayhem = fn(list) -&gt; [99999 | list] end

top_scores = [98, 95, 89]
cause_mayhem.(top_scores) # =&gt; [99999, 98, 95, 89]
Enum.max(top_scores)      # =&gt; 98
</code></pre>

<p>Although <code>cause_mayhem</code> returned a <em>new</em> list, it didn&rsquo;t alter the existing list. Changing the value of an existing item is impossible with Elixir! Because of this, you never have to worry about passing your value to another function. It <em>can&rsquo;t</em> mess up existing code!</p>

<h2>Data: Solution</h2>

<p>The Ruby solution is to write classes whose state is immutable.</p>

<p>A <em>mutable</em> class is one whose instance variables change during its lifetime. An <em>immutable</em> class is one whose instance variables <em>never</em> change during its lifetime.</p>

<p>Here&rsquo;s an example of refactoring a mutable class to be immutable.</p>

<p>First, a mutable <code>Counter</code>:</p>

<pre><code class="ruby">class MutableCounter
  attr_reader :count

  def initialize
    @count = 0
  end

  # Adds one to the internal value
  def increment
    @count += 1
  end
end
</code></pre>

<p>Now, here&rsquo;s the problem with this class. It leads to unpredictable code:</p>

<pre><code class="ruby">counter = MutableCounter.new
counter.count         # =&gt; 0
counter.increment
counter.count         # =&gt; 1
cause_mayhem(counter)
counter.count         # =&gt; ????
</code></pre>

<p>It could be mutated by <code>cause_mayhem</code>&hellip; but we have no idea!</p>

<p>Next, an immutable <code>Counter</code> class</p>

<pre><code class="ruby">class ImmutableCounter
  attr_reader :count

  def initialize(count: 0)
    @count = count
  end

  # Return a _new_ ImmutableCounter with an incremented count
  def increment
    self.class.new(count: @count + 1)
  end
end
</code></pre>

<p>No matter how you call methods on that object, its <code>@count</code> will not change after initialization.</p>

<p>Here&rsquo;s our problem code again:</p>

<pre><code class="ruby">counter = ImmutableCounter.new
counter.count         # =&gt; 0
counter = counter.increment
counter.count         # =&gt; 1
cause_mayhem(counter)
counter.count         # =&gt; 1 üéä  
</code></pre>

<p>There&rsquo;s no way <code>cause_mayhem</code> could alter our counter!</p>

<p><strong>But,</strong> what if you <em>want</em> to alter the value by some other method?</p>

<p>Easy: just make the method <em>return</em> the value you want to use. Here&rsquo;s a modified example:</p>

<pre><code class="ruby"># Increment the counter three times and return the new one
def modify_counter(counter)
  counter = counter.increment
  counter = counter.increment
  counter = counter.increment
  counter
end

# usage:

counter = ImmutableCounter.new
counter.count             # =&gt; 0
# store the old counter, just for example:
previous_counter = counter
# reassign the counter
counter = modify_counter(counter)
# counter has the new value:
counter.count           # =&gt; 3
# previous_counter was unchanged:
previous_counter.count  # =&gt; 0
</code></pre>

<p>In this case, the caller must <em>explicitly</em> receive the new value from the function. This makes it obvious to the reader that the function returned a new, useful value!</p>

<h2>Behavior: Problem</h2>

<p>In Ruby, classes express <em>behavior</em> by exposing public methods. These methods may alter internal state (like <code>MutableCounter#increment</code>). Shared code may be DRYed up by being relocated to a private method.</p>

<p>Here&rsquo;s an example:</p>

<pre><code class="ruby">class BaseballTeam
  # ...
  def add_player(player)
    @players &lt;&lt; player
    # reset cached averages, etc:
    update_team_aggregates
  end
end
</code></pre>

<p>The problem is that state changes are scattered throughout the code. Some are visible inline, some are out-of-sight. This makes <code>BaseballTeam</code> harder to understand.</p>

<p>To learn the behavior of <code>add_player</code>, must also know the behavior of <code>update_team_aggregates</code>. <em>Any</em> part of the <code>BaseballTeam</code>&rsquo;s internal state could have been altered in any way! At the end of the method body, there&rsquo;s no guarantee that <code>@players</code> contains the same objects it at the start of the method body. üò¢.</p>

<p>In Elixir, any behavior that <em>would</em> mutate an object actually creates a <em>new</em> object. The analogous code is:</p>

<pre><code class="elixir">defmodule BaseballTeam do
  def add_player(team, player) do
    players = [player | team.players]
    [avg_batting_avg, avg_salary, avg_pitching_record] = calculate_aggregates(players)
    %{team | players: players, avg_batting_avg: avg_batting_avg, avg_salary: avg_salary, avg_pitching_record: avg_pitching_record}
  end
end
</code></pre>

<p>In this case, it&rsquo;s clear exactly which keys of the <code>BaseballTeam</code> struct are updated when a players is added. It&rsquo;s impossible for <code>calculate_aggregates</code> to alter any other part of the <code>team</code>!</p>

<h2>Behavior: Solution</h2>

<p>The Ruby solution is to write methods as pure functions, that is, methods which use their arguments as their <em>only</em> input (no accessing <code>self</code>) and provide a return value as their <em>only</em> output (no side-effects).</p>

<p>Here&rsquo;s a rewritten Ruby example:</p>

<pre><code class="ruby">class BaseballTeam
  # ...
  def add_player(player)
    @players &lt;&lt; player
    @avg_batting_avg, @avg_salary, @avg_pitching_record = calculate_aggregates(@players)
  end
end
</code></pre>

<p>In this case, it&rsquo;s obvious which members of the <code>team</code>&rsquo;s internal state will be modified by <code>add_player</code>. However, a developer <em>could</em> break the purely functional contract of <code>calculate_aggregates</code>.</p>

<p>To avoid that, refactor <code>BaseballTeam</code> to be a composition of <code>@players</code> and <code>@aggregates</code>:</p>

<pre><code class="ruby">class BaseballTeam
  class AggregateStats
    def initialize(players)
     # ...
    end
    # ...
  end
  # ...
  def add_player(player)
    @players &lt;&lt; player
    @aggregates = AggregateStats.new(@players)
  end

  # Aggregate methods delegate to the AggregateStats object:
  def avg_salary
    @aggregates.avg_salary
  end
end  
</code></pre>

<p>Further defensive techniques could be taken, such as:</p>

<ul>
<li>Creating a <em>new</em> <code>@players</code> array instead of mutating the existing one.</li>
<li>Freezing <code>@players</code> to prevent other code from changing it</li>
</ul>


<p>Those measures would guarantee correct state, but they may be &ldquo;overkill&rdquo; for some uses!</p>

<h2>Conclusion</h2>

<p>I can&rsquo;t magically transform my Ruby app into an Elixir app, but I <em>can</em> take some of the lessons learned from Elixir and apply them to Ruby code! Plus, Ruby gives us the ability to mutate state when necessary (for example, when performance is critical).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How many assertions per test case?]]></title>
    <link href="http://rmosolgo.github.io/blog/2015/10/08/how-many-assertions-per-test-case/"/>
    <updated>2015-10-08T21:12:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2015/10/08/how-many-assertions-per-test-case</id>
    <content type="html"><![CDATA[<p>This question is too hard. Instead, ask, &ldquo;how many behaviors per test case?&rdquo; and answer, &ldquo;one.&rdquo;</p>

<!-- more -->


<p>I presented at Full Stack about unit testing but what I really like is behavior-driven development.</p>

<h2>A Behavior</h2>

<p>You can think of a code base as a collection of behaviors: given some inputs (data, events), it makes some outputs (more data, more events). In this perspective, the code itself is an implementation detail. As long as it takes the inputs and creates the outputs, it makes little difference what classes, methods, functions etc, implement that behavior.</p>

<p>This kind of thinking is recursive: each behavior is composed of smaller behaviors. For example, in a web application:</p>

<pre><code>Behavior:
  - A request with a valid username &amp; password is allowed to take Action X

    Is composed of:
      - The user info is stored in the session
      - The user's `last_logged_in_at` is updated
      - Value Y is written to the database
</code></pre>

<p>Each subsequent level of behavior may have an implementation of its own.</p>

<h2>Testing a behavior</h2>

<p>In a web application, unauthorized requests:</p>

<ul>
<li>Return meaningful HTTP responses, including a status and a body; and</li>
<li>do not execute the requested action</li>
</ul>


<p>I would specify that as two <em>behaviors</em>:</p>

<pre><code class="ruby">describe "an unauthorized request" do
  it "responds as not authorized" do
    http_response = make_create_request # makes a unauthorized_request
    assert_equal(403, http_response.status)
    assert_equal("Not Authorized", http_response.body)
  end

  it "doesn't write to the database" do
    http_response = make_create_request # makes a unauthorized_request
    assert_equal(0, Posts.count)
  end  
end
</code></pre>

<p>(using <a href="https://github.com/seattlerb/minitest#specs">minitest/spec</a>)</p>

<p>Notice that the first test made <em>two</em> assertions. You could split that into three test cases but I don&rsquo;t think it&rsquo;s worth the trouble. What&rsquo;s the case where <code>403</code> and <code>"Not Authorized"</code> are not part of the same behavior?</p>

<h2>Multiple Assertions is a Code Smell</h2>

<p>If your test case has many assertions, your code may be telling you that you&rsquo;re specifying multiple behaviors at once. Ask yourself:</p>

<ul>
<li>Is there a smaller unit of work to extract?</li>
<li>Can I make this a two-step process, where step one&rsquo;s result is passed to step two?</li>
<li>Can I break each test case (and its corresponding code) into a distinct <a href="http://c2.com/cgi/wiki?StrategyPattern">strategy</a>?</li>
<li>Am I testing business logic <em>and</em> interaction with an external service (eg, your database or an HTTP service)? Can I separate the two actions?</li>
<li>Am I transforming data, then acting based on the result? Can I separate those two?</li>
<li>Are there assertions that are shared between multiple test cases? Is there an underlying behavior there?</li>
</ul>


<h2>Other People on The Internet</h2>

<p>Here&rsquo;s some more dignified reading on the topic:</p>

<ul>
<li><strong><a href="http://dannorth.net/introducing-bdd/">&ldquo;Introducing BDD,&rdquo; Dan North</a></strong>. I especially agree with his point that behavior-driving thinking helps you focus your design and implementation.</li>
<li><strong><a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">&ldquo;Testing One Assertion Per Test,&rdquo; Jay Fields</a></strong>. I basically agree with him: &ldquo;Tests that focus on one behavior of the system are almost always easier to write and to comprehend at a later date.&rdquo; But I disagree with his assumption that one behavior equals one assertion.</li>
<li><strong><a href="http://programmers.stackexchange.com/a/7829">&ldquo;Is it OK to have multiple asserts in a single unit test?&rdquo;, random Stack Overflow people</a></strong>. &ldquo;Yeah, but try not to.&rdquo;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Crystal First Impressions]]></title>
    <link href="http://rmosolgo.github.io/blog/2015/09/27/crystal-first-impressions/"/>
    <updated>2015-09-27T21:47:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2015/09/27/crystal-first-impressions</id>
    <content type="html"><![CDATA[<p>The <a href="http://crystal-lang.org/">Crystal programming language</a> combines Ruby-like syntax with a really powerful compiler. As a result, it&rsquo;s fun to write, fast to run, and hard to screw up!</p>

<!-- more -->


<p>My Crystal experience so far:</p>

<ul>
<li><a href="https://github.com/danott">danott</a> mentioned it in our Slack a few weeks ago</li>
<li>I read the great <a href="http://crystal-lang.org/docs/">Crystal docs</a></li>
<li>I cobbled together <a href="https://github.com/rmosolgo/crythtal">a lisp (barely)</a></li>
</ul>


<p>I&rsquo;d say it&rsquo;s a combination of:</p>

<ul>
<li>a more-stable-Ruby (like Elixir, but without Erlang)</li>
<li>a developer-friendly, life-embetter-ing type system (like Elm, but &hellip; not JavaScript)</li>
<li>a real compiler! (like C, but fun to read and write)</li>
</ul>


<p>Um, what else could you want?! (See last paragraph üòõ)</p>

<h2>Crystal Syntax</h2>

<p>Crystal brings the best of Ruby:</p>

<ul>
<li><strong>Concise literals</strong>, just like Ruby (take it for granted until you use regexps in Python üôÄ)</li>
<li><strong>Great OO support</strong>, classes &amp; modules just like Ruby</li>
<li><strong>Attractive syntax</strong> thanks to blocks, operator overloading and optional parens</li>
<li><strong>consistent</strong>, predictable standard library (like Ruby)</li>
</ul>


<p>Plus, some improvements over Ruby:</p>

<ul>
<li><strong>Method overloading</strong></li>
<li>Python-like <strong>keyword args</strong>: must have default value, may be passed as kwargs or positional args (I could go either way on this since Ruby 2.1, but it beats <code>options={}</code>)</li>
<li>More robust <strong>Proc literals</strong>, reminded me of Elixir</li>
<li>Convention: <strong><code>?</code> methods return maybe-nil types</strong>, while their counterparts raise on nil</li>
<li>First-class <strong>enums</strong> &amp; <strong>tuples</strong></li>
<li><strong>Immutable strings</strong>, like Ruby 3 will have (?)</li>
</ul>


<p>For completeness, you lose some things from Ruby:</p>

<ul>
<li>Runtime <strong>code creation</strong>, like <code>define_method</code> &amp; friends</li>
<li>Runtime <strong>code evaluation</strong>, like <code>eval</code> &amp; friends</li>
</ul>


<p>Crystal offers a powerful <strong>macro system</strong> that makes up for the loss of runtime metaprogramming. Unlike C preprossing, Crystal macros are awesome. You basically define functions which are called at compile-time, then generate code with liquid-like syntax.</p>

<h2>Crystal Typing</h2>

<h3>Inferring Types</h3>

<p>Crystal infers types from your code, so these are OK:</p>

<pre><code class="ruby">my_string = "Hello World"
# String
my_hash = {key: "value", key2: "value2"}
# Hash(Symbol, String)
my_array = [1,2,3]
# Array(Int32)
</code></pre>

<p>When types mix, Crystal automatically unions them. It will ensure any usages of the variable in question are valid for both types. For example:</p>

<pre><code class="ruby">my_variable = "string"
my_variable = 1
# String | Int32

# Ok, because String &amp; Int32 both implement #to_f
my_variable.to_f

# You can add runtime checks to call type-specific methods
if my_variable.is_a?(String)
  my_variable.upcase
end
</code></pre>

<p>There are some times you need to define types to help the compiler. For example, there aren&rsquo;t any values here to tell the compiler what to expect:</p>

<pre><code class="ruby">some_array =  [] of Int32
# You can use custom types, too
some_hash =   {} of Symbol =&gt; SomeCustomClass
</code></pre>

<h3>Goodbye, NoMethodErrors</h3>

<p>If you&rsquo;re like me, you hate this:</p>

<pre><code>undefined method `whatever' for nil:NilClass
</code></pre>

<p>Something somehow became nil. üò¢</p>

<p>Instead, Crystal reads your code, and if there&rsquo;s somewhere a value could be nil, it throws a compile error:</p>

<pre><code>in ./src/lisp/binding.cr:55: undefined method 'find_owner' for Nil

      @parent.find_owner(key)
              ^~~~~~~~~~
</code></pre>

<p>You have two options:</p>

<ul>
<li>Add an explicit not-nil check (<code>if object.is_a?(String) ...</code>) so the compiler knows it will be safe</li>
<li>Refactor so the value won&rsquo;t be nil</li>
</ul>


<p>Of course, the first one seems better at the start, but I hope to get better at the second one üòÅ.</p>

<h2>What&rsquo;s Missing?</h2>

<p>Crystal really shows its youth. Its shortcomings all fall in that vein:</p>

<ul>
<li><strong>Poorly documented</strong>, which isn&rsquo;t so bad if you&rsquo;re coming from Ruby</li>
<li><strong>Few projects</strong> out there (I think the <a href="http://crystalshards.herokuapp.com/">package repository is a free Heroku app</a>)</li>
<li>Standard library has <strong>some kinks</strong>, they say it is still changing</li>
</ul>


<p>One example of a standard library kink is the handling of <code>break</code>, <code>next</code> and <code>return</code> in blocks. If you want to exit a block early, you have to choose one of those three. The problem is that, to choose the right one, you have to know whether the method captures the block into a proc or simply yields values to it. It&rsquo;s a drag to have to know a method&rsquo;s implementation to call it! (IRL, I didn&rsquo;t run into this and I suspect it would be easy enough to work around it.)</p>

<h2>Now What?</h2>

<p>I really liked Crystal and I hope I can work with it more!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Response to "Using a Ruby Class to Write Functional Code"]]></title>
    <link href="http://rmosolgo.github.io/blog/2015/03/15/response-to-using-a-ruby-class-to-write-functional-code/"/>
    <updated>2015-03-15T14:29:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2015/03/15/response-to-using-a-ruby-class-to-write-functional-code</id>
    <content type="html"><![CDATA[<p>Pat Shaughnessy&rsquo;s <a href="http://patshaughnessy.net/2014/4/8/using-a-ruby-class-to-write-functional-code">&ldquo;Using a Ruby Class to Write Functional Code&rdquo;</a> gives an example of bringing functional programming principles into object-oriented design. I like it.</p>

<!-- more -->


<p>It Pat&rsquo;s example, he turns a group of pure functions into a class whose state is <em>immutable-ish</em> (they technically could be changed, but they aren&rsquo;t) &amp; whose methods are <em>pure-ish</em> (they read from internal state, too). He says:</p>

<blockquote><p>You‚Äôve broken the rules and rewritten your pure, functional program in a more idiomatic, Ruby manner. However, you haven‚Äôt lost the spirit of functional programming. Your code is just as easy to understand, maintain and test.</p></blockquote>

<p><a href="http://patshaughnessy.net/2014/4/8/using-a-ruby-class-to-write-functional-code#comment-1331596525">One commenter</a> goes further:</p>

<blockquote><p>I think you do not break the rules of FP by relying on <code>@line</code> and <code>@values</code>. <code>@line</code> is just partially applying a parameter to the &ldquo;functions&rdquo; of Line and currification is a usual techique in FP. <code>@values</code> is memoizing the result of a function which also comes from FP.</p></blockquote>

<p>There were a few ideas that jumped out at me.</p>

<h2>&ldquo;No Side-effects&rdquo; = Clarity at the Call Site</h2>

<p>Functions that don&rsquo;t modify their arguments are often easier to use. Their usage <em>reveals intent</em>.</p>

<p>Which do you prefer:</p>

<pre><code class="ruby">def exclaim_1(statement)
  # modify the argument
  statement &lt;&lt; "!!!"
  return nil
end

wow = "Wow"
exclaim_1(wow)  # =&gt; nil
wow             # =&gt; "Wow!!!"
</code></pre>

<p>or:</p>

<pre><code class="ruby">def exclaim_2(statement)
  # make a new string
  return statement + "!!!"
end

wow = "Wow"
such_wow = exclaim_2(wow) # =&gt; "Wow!!!"
wow                       # =&gt; "Wow"
such_wow                  # =&gt; "Wow!!!"
</code></pre>

<p>In the first case, if you didn&rsquo;t have the output in front of you, you wouldn&rsquo;t know what <code>exclaim_1</code> did. You&rsquo;d have to find the file and read the method body to know its purpose.</p>

<p>In the second case, it&rsquo;s obvious at the call site that the function returns a new, significant value. (Otherwise, why would the developer have captured in a new variable?)</p>

<h2>Think of <code>self</code> as an Argument</h2>

<p>You can extend the benefit of call site clarity to an object&rsquo;s internal state, too.</p>

<p>The commenter mentions that &ldquo;<code>@line</code> is like a parameter&rdquo; to the class&rsquo;s methods. Although it <em>isn&rsquo;t</em> part of the method signature, it has some parameter-like properties. It is:</p>

<ul>
<li>A value which affects the output</li>
<li>Unchanged by the function</li>
</ul>


<p>What if you <em>always</em> treated <code>self</code> like that? I mean, you didn&rsquo;t modify it inside method bodies, you treated it as read-only (as often as possible).</p>

<p>Python really invites you to think of <code>self</code> as a parameter of the function. It&rsquo;s actually part of the method signature:</p>

<pre><code class="python">class Something():
  def some_method(self, arg_1, arg2):
    self # =&gt; the instance
    return "whatever"
</code></pre>

<p>In fact, PyCharm will even complain if you modify <code>self</code> during a method:</p>

<p><img src="/images/pycharm_ivar.png" width="500"></p>

<p>(In reality, <code>self</code> <em>is</em> an argument in any language runtime that I ever heard of &hellip; we just tend not to think of it that way!)</p>

<h2>What Gives?</h2>

<p>I spend most of my time <em>maintaining</em> software and FP pays off big time in that regard:</p>

<ul>
<li><strong>Tests are more reliable</strong> for pure functions: if the function yields the correct output with those inputs today, it will <em>always</em> yield the correct output with those inputs.</li>
<li>Pure functions are <strong>easy to understand</strong>: the only factors are the inputs and there&rsquo;s no muddling from outside universe. Knowledge of the function body is sufficent to understand the function.</li>
<li>Pure functions must be <strong>decoupled</strong>. The only touch the world via <em>inputs</em> and <em>outputs</em> so they can&rsquo;t depend on anything else.</li>
</ul>

]]></content>
  </entry>
  
</feed>
