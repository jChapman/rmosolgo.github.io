<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Robert Mosolgo]]></title>
  <link href="http://rmosolgo.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://rmosolgo.github.io/"/>
  <updated>2017-10-05T13:05:16-04:00</updated>
  <id>http://rmosolgo.github.io/</id>
  <author>
    <name><![CDATA[Robert Mosolgo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What's new in React-Rails 2.0?]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/04/13/whats-new-in-react-rails-2-dot-0/"/>
    <updated>2017-04-13T11:59:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/04/13/whats-new-in-react-rails-2-dot-0</id>
    <content type="html"><![CDATA[<p>For <a href="http://planning.center">Planning Center</a> free week, I cooked up <a href="https://github.com/reactjs/react-rails"><code>react-rails</code></a> 2.0 üéä.</p>

<!-- more -->


<p>Here are a few highlights. For the full list, see the <a href="https://github.com/reactjs/react-rails/blob/master/CHANGELOG.md">changelog</a>!</p>

<h2>Webpacker support</h2>

<p><a href="https://github.com/rails/webpacker">Webpacker</a> was great to work with. <code>react-rails</code> now supports webpacker for:</p>

<ul>
<li>Mounting components with <code>&lt;%= react_component(...) %&gt;</code> via <code>require</code></li>
<li>Server rendering from a webpacker pack (<code>server_rendering.js</code>)</li>
<li>Loading the unobtrusive JavaScript (UJS)</li>
<li>Installation and component generators</li>
</ul>


<p>A nice advantage of using webpacker is that you can load React.js from NPM instead of the <code>react-rails</code> gem. This way, you aren&rsquo;t bound to the React.js version which is included with the Ruby gem. You can pick any version you want!</p>

<h2>UJS on npm</h2>

<p>To support frontends built with Node.js, <code>react-rails</code>&rsquo;s  UJS driver is available on NPM as <a href="https://www.npmjs.com/package/react_ujs"><code>react_ujs</code></a>. It performs setup during <code>require</code>, so these two are equal:</p>

<pre><code class="js">// Sprockets:
//= require react_ujs

// Node, etc:
require("react_ujs")
</code></pre>

<h2>Request-based prerender context</h2>

<p>If you&rsquo;re prerendering your React components on the server, you can perform setup and teardown in your Rails controller. For example, you might use these hooks to populate a flux store.</p>

<p>First, add the <code>per_request_react_rails_prerenderer</code> helper to your controller:</p>

<pre><code class="ruby">class PagesController &lt; ApplicationController
  per_request_react_rails_prerenderer
  # ...
end
</code></pre>

<p>Then, you can access <code>react_rails_prerenderer</code> in the controller action:</p>

<pre><code class="ruby">def show
  js_context = react_rails_prerenderer.context
  js_context.exec(js_setup_code)
  render :show
  js_context.exec(js_teardown_code)
end
</code></pre>

<p>That way, you can properly prepare &amp; clean up a JS VM for server rendering.</p>

<h2>Re-detect events</h2>

<p>Previously, <code>ReactRailsUJS</code> &ldquo;automatically&rdquo; detected which libraries you were using and hooked up to their events for rendering components.</p>

<p>It still checks for libraries during its initial load, but you can <em>also</em> re-check as needed:</p>

<pre><code class="js">// Check the global context for libraries like Turbolinks and hook up to them:
ReactRailsUJS.detectEvents()
</code></pre>

<p>This function removes previous event handlers, so it&rsquo;s safe to call anytime. (This was added in <code>2.0.2</code>.)</p>

<h2>Other Takeaways</h2>

<p>See the <a href="https://github.com/reactjs/react-rails/blob/master/CHANGELOG.md">changelog</a> for bug fixes and a new default server rendering configuration.</p>

<p>Webpacker is great! Setup was smooth and the APIs were clear and convenient. I&rsquo;m looking forward to using it more.</p>

<p>üçª Here&rsquo;s to another major version of <code>react-rails</code>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Watching files during Rails development]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/04/12/watching-files-during-rails-development/"/>
    <updated>2017-04-12T14:09:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/04/12/watching-files-during-rails-development</id>
    <content type="html"><![CDATA[<p>You can tell Ruby on Rails to respond to changes in certain files during development.</p>

<!-- more -->


<p>Rails knows to watch <code>config/routes.rb</code> for changes and reload them when the files change. You can use the same mechanism to watch other files and take action when they change.</p>

<p>I used this feature for <a href="https://github.com/reactjs/react-rails">react-rails</a> server rendering and for <a href="http://graphql.pro">GraphQL::Pro</a> static queries.</p>

<h2>app.reloader</h2>

<p>Every Rails app has <a href="https://github.com/rails/rails/blob/8f59a1dd878f56798f88369fa5b448f17a29679d/railties/lib/rails/application.rb#L135">a <code>@reloader</code></a>, which is a local subclass of <a href="http://api.rubyonrails.org/classes/ActiveSupport/Reloader.html"><code>ActiveSupport::Reloader</code></a>. It&rsquo;s used whenever you call <a href="https://github.com/rails/rails/blob/fe1f4b2ad56f010a4e9b93d547d63a15953d9dc2/railties/lib/rails/console/app.rb#L29-L34"><code>reload!</code> in the Rails console</a>.</p>

<p>It&rsquo;s attached to a <a href="https://github.com/rails/rails/blob/d3c9d808e3e242155a44fd2a89ef272cfade8fe8/railties/lib/rails/application/default_middleware_stack.rb#L51-L53">rack middleware</a> which <a href="https://github.com/rails/rails/blob/d3c9d808e3e242155a44fd2a89ef272cfade8fe8/actionpack/lib/action_dispatch/middleware/executor.rb#L10">calls <code>#run!</code></a> (which, in turn, <a href="https://github.com/rails/rails/blob/291a098c111ff419506094e14c0186389b0020ca/activesupport/lib/active_support/reloader.rb#L57-L63">calls the reload blocks if it detects changes</a>).</p>

<h2>config.to_prepare</h2>

<p>You can add custom preparation hooks with <code>config.to_prepare</code>:</p>

<pre><code class="ruby">initializer :my_custom_preparation do |app|
  config.to_prepare do
    puts "Reloading now ..."
  end
end
</code></pre>

<p>When Rails detects a change, this block will be called. It&rsquo;s implemented by <a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L53-L55">registering the block with <code>app.reloader</code></a>.</p>

<h2>app.reloaders</h2>

<p>To add <em>new conditions</em> for which Rails should reload, you can add to the <a href="https://github.com/rails/rails/blob/8f59a1dd878f56798f88369fa5b448f17a29679d/railties/lib/rails/application.rb#L126"><code>app.reloaders</code> array</a>:</p>

<pre><code class="ruby"># Object responds to `#updated?`
class MyWatcher
  def updated?
    # ...
  end
end

# ...

initializer :my_custom_watch_condition do |app|
  # Register custom reloader:
  app.reloaders &lt;&lt; MyWatcher.new
end
</code></pre>

<p>The object&rsquo;s <a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L156-L158"><code>updated?</code> method will be called</a> by the reloader. If any reloader returns <code>true</code>, the middleware will run all <code>to_prepare</code> blocks (via the call to <code>@reloader.run!</code>).</p>

<h2>FileUpdateChecker</h2>

<p>Rails includes a goodie for watching files. <a href="http://api.rubyonrails.org/classes/ActiveSupport/FileUpdateChecker.html"><code>ActiveSupport::FileUpdateChecker</code></a> is great for:</p>

<ul>
<li>Watching specific files for changes (<a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/routes_reloader.rb#L41"><code>config/routes.rb</code> is watched this way</a>)</li>
<li>Watching a directory of files for changes, additions and deletions (<a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L164"><code>app/**/*.rb</code> is watched this way</a>)</li>
</ul>


<p>You can create your own <code>FileUpdateChecker</code> and add it to <code>app.reloaders</code> to reload Rails when certain files change:</p>

<pre><code class="ruby"># Watch specific files:
app.reloaders &lt;&lt; ActiveSupport::FileUpdateChecker.new(["my_important_file.txt", "my_other_important_file.txt"])
# Watch directory-extension pairs, eg all `.txt` and `.md` files in `app/important_files` and subdirectories:
app.reloaders &lt;&lt; ActiveSupport::FileUpdateChecker([], { "app/important_files" =&gt; [".txt", ".md"] })
</code></pre>

<p>Some filesystems support an evented file watcher implementation, <a href="http://api.rubyonrails.org/classes/ActiveSupport/EventedFileUpdateChecker.html"><code>ActiveSupport::EventedFileUpdateChecker</code></a>. <code>app.config.file_watcher</code> will return the proper filewatcher class for the current context.</p>

<pre><code class="ruby">app.reloaders &lt;&lt; app.config.file_watcher(["my_important_file.txt", "my_other_important_file.txt"])
</code></pre>

<h2>All Together Now</h2>

<p><code>react-rails</code> maintains a pool of V8 instances for server rendering React components. These instances are initialized with a bunch of JavaScript code, and whenever a developer changes a JavaScript file, we need to reload them with the new code. This requires two steps:</p>

<ul>
<li>Adding a new watcher to <code>app.reloaders</code> to detect changes to JavaScript files</li>
<li>Adding a <code>to_prepare</code> hook to reload the JS instances</li>
</ul>


<p>It looks basically like this:</p>

<pre><code class="ruby">initializer "react_rails.watch_js_files" do |app|
  # Watch for changes to javascript files:
  app.reloaders &lt;&lt; app.config.file_watcher.new([], {
    # Watch the asset pipeline:
    Rails.root.join("app/assets/javascripts").to_s =&gt; ["jsx", "js"],
    # Watch webpacker:
    Rails.root.join("app/javascript").to_s =&gt; ["jsx", "js"]
  })

  config.to_prepare do
    React::ServerRendering.reset_pool
  end
end
</code></pre>

<p>The <a href="https://github.com/reactjs/react-rails/blob/bbb1ff10c787ca6a186e39df57fe5b228b37bd7e/lib/react/rails/railtie.rb#L26-L39">full implementation</a> supports some customization. You can see similar (and more complicated) examples with <a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L126-L142">routes reloading</a>, <a href="https://github.com/rails/rails/blob/e9abbb700acd8165a8994d8b2a700e507fb3b7ff/activesupport/lib/active_support/i18n_railtie.rb#L59-L74">i18n reloading</a> and <a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L163-L183"><code>.rb</code> reloading</a>.</p>

<p>Happy reloading!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prototyping a GraphQL Schema From Definition With Ruby]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/03/17/prototyping-a-graphql-schema-from-definition-with-ruby/"/>
    <updated>2017-03-17T15:49:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/03/17/prototyping-a-graphql-schema-from-definition-with-ruby</id>
    <content type="html"><![CDATA[<p>GraphQL 1.5.0 includes a new way to define a schema: from a GraphQL definition.</p>

<!-- more -->


<p>In fact, loading a schema this way has been supported for while, but 1.5.0 adds the ability to specify field resolution behavior.</p>

<h2>GraphQL IDL</h2>

<p>Besides queries, GraphQL has an <em>interface definition language</em> (IDL) for expressing a schema‚Äôs structure. For example:</p>

<pre><code class="ruby">schema {
  query: Query
}

type Query {
  post(id: ID!): Post
}

type Post {
  title: String!
  comments: [Comment!]
}
</code></pre>

<p>You can turn a definition into a schema with <code>Schema.from_definition</code>:</p>

<pre><code class="ruby">schema_defn = "..."
schema = GraphQL::Schema.from_definition(schema_defn)
</code></pre>

<p>(By the way, the IDL is technically in <a href="https://github.com/facebook/graphql/pull/90">RFC stage</a>.)</p>

<h2>Resolvers</h2>

<p><code>Schema.from_definition</code> also accepts <code>default_resolve:</code> argument. It expects one of two inputs:</p>

<ul>
<li>A nested hash of type <code>Hash&lt;String =&gt; Hash&lt;String =&gt; #call(obj, args, ctx)&gt;&gt;</code>; or</li>
<li>An object that responds to <code>#call(type, field, obj, args, ctx)</code></li>
</ul>


<h4>Resolving with a Hash</h4>

<p>When you‚Äôre using a hash:</p>

<ul>
<li>The first key is a <em>type name</em></li>
<li>The second key is a <em>field name</em></li>
<li>The last value is a <em>resolve function</em> (<code>#call(obj, args, ctx)</code>)</li>
</ul>


<p>To get started, you can write the hash manually:</p>

<pre><code class="ruby">{
  "Query" =&gt; {
    "post" =&gt; -&gt;(obj, args, ctx) { Post.find(args[:id]) },
  },
  "Post" =&gt; {
    "title" =&gt; -&gt;(obj, args, ctx) { obj.title },
    "body" =&gt; -&gt;(obj, args, ctx) { obj.body },
    "comments" =&gt; -&gt;(obj, args, ctx) { obj.comments },
  },
}
</code></pre>

<p>But you can also reduce a lot of boilerplate by using a hash with default values:</p>

<pre><code class="ruby"># This hash will fall back to default implementation if another value isn't provided:
type_hash = Hash.new do |h, type_name|
  # Each type gets a hash of fields:
  h[type_name] = Hash.new do |h2, field_name|
    # Default resolve behavior is `obj.public_send(field_name, args, ctx)`
    h2[field_name] = -&gt;(obj, args, ctx) { obj.public_send(field_name, args, ctx) }
  end
end

type_hash["Query"]["post"] = -&gt;(obj, args, ctx) { Post.find(args[:id]) }

schema = GraphQL::Schema.from_definition(schema_defn, default_resolve: type_hash)
</code></pre>

<p>Isn‚Äôt that a nice way to set up a simple schema?</p>

<h4>Resolving with a Single Function</h4>

<p>You can provide a single callable that responds to <code>#call(type, field, obj, args, ctx)</code>. What a mouthful!</p>

<p>The <em>advantage</em> of that hefty method signature is that it‚Äôs enough to specify any resolution behavior you can imagine. For example, you could create a system where type modules were found by name, then methods were called by name:</p>

<pre><code class="ruby">module ExecuteGraphQLByConvention
  module_function
  # Find a Ruby module corresponding to `type`,
  # then call its method corresponding to `field`.
  def call(type, field, obj, args, ctx)
    type_module = Object.const_get(type.name)
    type_module.public_send(field.name, obj, args, ctx)
  end
end

schema = GraphQL::Schema.from_definition(schema_defn, default_resolve: ExecuteGraphQLByConvention)
</code></pre>

<p>So, a single function combined with Ruby‚Äôs flexibility and power opens a lot of doors!</p>

<p>Doesn‚Äôt it remind you a bit of method dispatch? The arguments are:</p>

<table>
<thead>
<tr>
<th>GraphQL Field Resolution </th>
<th> Method Dispatch</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>type</code> </td>
<td> class</td>
</tr>
<tr>
<td><code>field</code> </td>
<td> method</td>
</tr>
<tr>
<td><code>obj</code> </td>
<td> receiver</td>
</tr>
<tr>
<td><code>args</code> </td>
<td> method arguments</td>
</tr>
<tr>
<td><code>ctx</code> </td>
<td> runtime state (cf <a href="https://github.com/mruby/mruby/blob/master/include/mruby.h#L257"><code>mrb_state</code></a>, <a href="https://github.com/antirez/redis/blob/unstable/src/modules/INTRO.md"><code>RedisModuleCtx</code></a>, or <a href="http://erlang.org/doc/tutorial/nif.html"><code>ErlNifEnv</code></a>)</td>
</tr>
</tbody>
</table>


<h2>Special Configurations</h2>

<p>Some schemas need other configurations in order to run:</p>

<ul>
<li><code>resolve_type</code> to support union and interface types</li>
<li>schema plugins like <a href="https://rmosolgo.github.io/graphql-ruby/pro/monitoring">monitoring</a> or custom <a href="https://rmosolgo.github.io/graphql-ruby/schema/instrumentation">instrumentation</a></li>
</ul>


<p>To add these to a schema, use <code>.redefine</code>:
```ruby</p>

<h1>Extend the schema with new definitions:</h1>

<p>schema = schema.redefine {
  resolve_type ->(obj, ctx) { &hellip; }
  monitoring :appsignal
}
```</p>

<h2>What‚Äôs Next?</h2>

<p>Rails has proven that ‚ÄúConvention over Configuration‚Äù can be a very productive way to start new projects, so I‚Äôm interested in exploring convention-based APIs on top of this feature.</p>

<p>In the future, I‚Äôd like to add support for schema annotations in the form of directives, for example:</p>

<pre><code class="ruby">type Post {
  comments: [Comment!] @relation(hasMany: "comments")
}
</code></pre>

<p>These could be used to customize resolution behavior. Cool!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tracking Schema Changes with GraphQL-Ruby]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/03/16/tracking-schema-changes-with-graphql-ruby/"/>
    <updated>2017-03-16T20:16:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/03/16/tracking-schema-changes-with-graphql-ruby</id>
    <content type="html"><![CDATA[<p>One way to keep an eye on your GraphQL schema is to check the definition into source control.</p>

<!-- more -->


<p>When modifying shared code or reconfiguring, it can be hard to tell how the schema will <em>really</em> change. To help with this, set up a <strong>snapshot test</strong> for your GraphQL schema! This way:</p>

<ul>
<li>Changes will be clearly visible in GraphQL IDL</li>
<li>You can keep the IDL up-to-date by adding a test to your suite</li>
</ul>


<p>You can even track the schema from different contexts if you&rsquo;re using <a href="https://rmosolgo.github.io/graphql-ruby/pro/authorization"><code>GraphQL::Pro</code>&rsquo;s authorization framework</a>.</p>

<p>This approach was first described in <a href="https://www.youtube.com/watch?v=Wlu_PWCjc6Y">GraphQL at Shopify</a>.</p>

<h2>Check It In</h2>

<p>Write a <strong>Rake task</strong> to get your schema&rsquo;s definition and write it to a file:</p>

<pre><code class="ruby"># lib/tasks/graphql.rake
rake dump_schema: :environment do
  # Get a string containing the definition in GraphQL IDL:
  schema_defn = MyAppSchema.to_definition
  # Choose a place to write the schema dump:
  schema_path = "app/graphql/schema.graphql"
  # Write the schema dump to that file:
  File.write(Rails.root.join(schema_path), schema_defn)
  puts "Updated #{schema_path}"
end
</code></pre>

<p>You can run it from terminal:</p>

<pre><code class="sh">$ bundle exec rake dump_schema
Updated app/graphql/schema.graphql
</code></pre>

<p>This updates the file in your repo. Go ahead and <strong>check it in</strong>!</p>

<pre><code class="sh">$ git add app/graphql/schema.graphql
$ git commit -m "Add GraphQL schema dump"
</code></pre>

<h2>Keep It Up to Date</h2>

<p>Any changes to the Ruby schema code must be reflected in the <code>.graphql</code> file. You can give yourself a reminder by adding a <strong>test case</strong> which asserts that the GraphQL definition is up-to-date:</p>

<pre><code class="ruby"># test/graphql/my_app_schema_test.rb
require "test_helper"

class MyAppSchemaTest &lt; ActiveSupport::TestCase
  def test_printout_is_up_to_date
    current_defn = MyAppSchema.to_definition
    printout_defn = File.read(Rails.root.join("app/graphql/schema.graphql"))
    assert_equal(current_defn, printout_defn, "Update the printed schema with `bundle exec rake dump_schema`")
  end
end
</code></pre>

<p>If the definition is stale, you&rsquo;ll get a failed test:</p>

<p><img src="/images/tracking_schema/test_failure.png" width="500"></p>

<p>This reminder is helpful in development and <em>essential</em> during code review!</p>

<h2>Review It</h2>

<p>Now that your schema definition is versioned along with your code, you can see changes during <strong>code review</strong>:</p>

<p><img src="/images/tracking_schema/code_review.png" width="600"></p>

<h2>Multiple Schema Dumps</h2>

<p>If your schema looks different to different users, you can track <em>multiple</em> schema dumps. This is helpful if:</p>

<ul>
<li>You&rsquo;re using the <code>:view</code> configuration of <a href="https://rmosolgo.github.io/graphql-ruby/pro/authorization"><code>GraphQL::Pro</code>&rsquo;s authorization</a></li>
<li>You&rsquo;re using <code>only:</code>/ <code>except:</code> to manually filter your schema</li>
</ul>


<p>Just provide the <code>context:</code> argument to <code>Schema.to_definition</code> as if you were running a query. (Also provide <code>only:</code>/<code>except:</code> if you use them.)</p>

<p>Print with a filter from the Rake task:</p>

<pre><code class="ruby"># lib/tasks/graphql.rake
task dump_schema: :environment do
  # ...
  admin_user = OpenStruct.new(admin?: true)
  admin_schema_dump = MyAppSchema.to_definition(context: { current_user: admin_user })
  admin_schema_path = "app/graphql/admin_schema.graphql"
  File.write(Rails.root.join(admin_schema_path), admin_schema_dump)
end
</code></pre>

<p>Test with a filter from the test case:</p>

<pre><code class="ruby">def test_printout_is_up_to_date
  # ...
  admin_user = OpenStruct.new(admin?: true)
  current_admin_defn = MyAppSchema.to_definition(context: { current_user: admin_user })
  printout_admin_defn = File.read(Rails.root.join("app/graphql/admin_schema.graphql"))
  assert_equal(current_admin_defn, printout_admin_defn, "Update the printed schema with `bundle exec rake dump_schema`")
end
</code></pre>

<p>Now you can keep an eye on the schema from several perspectives!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optimizing GraphQL-Ruby]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/03/08/optimizing-graphql-ruby/"/>
    <updated>2017-03-08T08:02:00-05:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/03/08/optimizing-graphql-ruby</id>
    <content type="html"><![CDATA[<p>Soon, <code>graphql-ruby</code> 1.5.0 will be released. Query execution will be ~70% faster than 1.3.0!</p>

<!-- more -->


<p>Let&rsquo;s look at how we reduced the execution time between those two versions. Thanks to <a href="https://github.com/theorygeek">@theorygeek</a> who optimized the middleware chain helped me pinpoint several other bottlenecks!</p>

<h2>The Benchmark</h2>

<p>To track GraphQL execution overhead, I <a href="https://github.com/rmosolgo/graphql-ruby/blob/master/benchmark/run.rb">execute the introspection query</a> on a <a href="https://github.com/rmosolgo/graphql-ruby/blob/master/spec/support/dummy/schema.rb">fixture schema</a> in graphql-ruby&rsquo;s test suite.</p>

<p>On GraphQL 1.3.0, the benchmark ran around 22.5 iterations per second:</p>

<p><img src="/images/optimizing_graphql_ruby/1-3-0-bench.png" width="500"></p>

<p>On <a href="https://github.com/rmosolgo/graphql-ruby/commit/943e68f40a11f3f809ecd8485282eccdd6a6991b">master</a>, it runs around 38 iterations per second:</p>

<p><img src="/images/optimizing_graphql_ruby/1-5-0-bench.png" width="500"></p>

<p>That&rsquo;s almost 1.7x faster!</p>

<pre><code class="ruby">38.0 / 22.5
# =&gt; 1.6888888888888889
</code></pre>

<p>So, how&rsquo;d we do it?</p>

<h2>Looking Under the Hood with RubyProf</h2>

<p>To find where time was spent, I turned to <a href="https://github.com/ruby-prof/ruby-prof">ruby-prof</a>. I <a href="https://github.com/rmosolgo/graphql-ruby/pull/579">wrapped GraphQL execution</a> with profiling and inspected the result:</p>

<pre><code class="text">Thread ID: 70149906635240
Fiber ID: 70149911114440
Total: 0.474618
Sort by: self_time

 %self      total      self      wait     child     calls  name
  4.60      0.074     0.022     0.000     0.052     6893  *Class#new
  3.99      0.019     0.019     0.000     0.000     8715  *GraphQL::Define::InstanceDefinable#ensure_defined
  3.13      0.015     0.015     0.000     0.000    25403   Module#===
  2.64      0.013     0.013     0.000     0.000     8813   Kernel#hash
  2.49      0.074     0.012     0.000     0.063     3496  *GraphQL::Schema::MiddlewareChain#call
  1.85      0.009     0.009     0.000     0.000     4184   GraphQL::Query::Context::FieldResolutionContext#query
  1.78      0.017     0.008     0.000     0.008     2141   #&lt;Module:0x007f9a18de37a8&gt;#type
  1.63      0.008     0.008     0.000     0.000     1960   GraphQL::Query::Context::FieldResolutionContext#initialize
  1.54      0.012     0.007     0.000     0.005     1748   GraphQL::Query#get_field
  1.53      0.014     0.007     0.000     0.006     1748   GraphQL::Query#arguments_for
  1.52      0.007     0.007     0.000     0.000     8356   Kernel#is_a?
  1.51      0.010     0.007     0.000     0.003     7523   Kernel#===
  1.44      0.022     0.007     0.000     0.015     1959   GraphQL::Query::Context::FieldResolutionContext#spawn
  1.32      0.012     0.006     0.000     0.006     1748   GraphQL::Execution::Lazy::LazyMethodMap#get
  1.31      0.010     0.006     0.000     0.003     1748   GraphQL::Execution::FieldResult#value=
  1.29      0.032     0.006     0.000     0.026     1748   GraphQL::Field#resolve
  1.25      0.042     0.006     0.000     0.037     1748   #&lt;Module:0x007f9a18de37a8&gt;#resolve
  1.16      0.015     0.006     0.000     0.010     1748   GraphQL::Execution::FieldResult#initialize
  1.06      0.010     0.005     0.000     0.005     2815   GraphQL::Schema::Warden#visible?
  1.05      0.014     0.005     0.000     0.009     1748   GraphQL::Schema::MiddlewareChain#initialize
  1.03      0.005     0.005     0.000     0.000     2815   &lt;Module::GraphQL::Query::NullExcept&gt;#call
  0.97      0.014     0.005     0.000     0.009      756   Hash#each_value
# ... truncated ...
</code></pre>

<p>A few things stood out:</p>

<ul>
<li>~5% of time was spent during ~7k calls to <code>Class#new</code>: this is time spent initializing new objects. I think initialization can also trigger garbage collection (if there&rsquo;s not a spot on the free list), so this may include GC time.</li>
<li>~4% of time was spent during ~9k calls to <code>InstanceDefinable#ensure_defined</code>, which is part of graphql-ruby&rsquo;s definition API. It&rsquo;s <em>all</em> overhead to support the definition API, üòø.</li>
<li>Several methods are called <code>1748</code> times. Turns out, this is <em>once per field in the response</em>.</li>
<li>With that in mind, <code>25,403</code> seems like a lot of calls to <code>Module#===</code>!</li>
</ul>


<h2>Reduce GC Pressure</h2>

<p>Since <code>Class#new</code> was the call with the most <code>self</code> time, I thought I&rsquo;d start there. What kind of objects are being allocated? We can filter the profile output:</p>

<pre><code class="text">~/code/graphql $ cat 130_prof.txt | grep initialize
  1.63      0.008     0.008     0.000     0.000     1960   GraphQL::Query::Context::FieldResolutionContext#initialize
  1.16      0.015     0.006     0.000     0.010     1748   GraphQL::Execution::FieldResult#initialize
  1.05      0.014     0.005     0.000     0.009     1748   GraphQL::Schema::MiddlewareChain#initialize
  0.69      0.006     0.003     0.000     0.002     1833   Kernel#initialize_dup
  0.46      0.002     0.002     0.000     0.000     1768   Array#initialize_copy
  0.30      0.001     0.001     0.000     0.000      419   GraphQL::Execution::SelectionResult#initialize
  0.28      0.001     0.001     0.000     0.000      466   Hash#initialize
  0.17      0.010     0.001     0.000     0.009       92   GraphQL::InternalRepresentation::Selection#initialize
  0.15      0.002     0.001     0.000     0.001      162   Set#initialize
  0.15      0.001     0.001     0.000     0.000       70   GraphQL::InternalRepresentation::Node#initialize
  0.07      0.001     0.000     0.000     0.001       58   GraphQL::StaticValidation::FieldsWillMerge::FieldDefinitionComparison#initialize
  0.04      0.001     0.000     0.000     0.000       64   GraphQL::Query::Arguments#initialize
  0.01      0.000     0.000     0.000     0.000       11   GraphQL::StaticValidation::FragmentsAreUsed::FragmentInstance#initialize
  0.01      0.000     0.000     0.000     0.000        1   GraphQL::Query#initialize
# ... truncated ...
</code></pre>

<p>Lots of GraphQL internals! That&rsquo;s good news though: those are within scope for optimization.</p>

<p><code>MiddlewareChain</code> was ripe for a refactor. In the old implementation, <em>each</em> field resolution created a middleware chain, then used it and discarded it. However, this was a waste of objects. Middlewares don&rsquo;t change during query execution, so we should be able to reuse the same list of middlewares for each field.</p>

<p>This required a bit of refactoring, since the old implementation modified the array (with <code>shift</code>) as it worked through middlewares. In the end, this improvement was added in <a href="https://github.com/rmosolgo/graphql-ruby/pull/462/commits/5549e0cff288a9aecd676603cbb62628a34b4ec8"><code>5549e0cf</code></a>. As a bonus, the number of created <code>Array</code>s (shown by <code>Array#initialize_copy</code>) also declined tremendously since they were used for <code>MiddlewareChain</code>&rsquo;s internal state. Also, calls to <code>Array#shift</code> were removed, since the array was no longer modified:</p>

<pre><code class="text">~/code/graphql $ cat 130_prof.txt | grep shift
  0.61      0.003     0.003     0.000     0.000     3496   Array#shift
~/code/graphql $ cat 150_prof.txt | grep shift
~/code/graphql $
</code></pre>

<p>üéâ !</p>

<p>The number <code>FieldResult</code> objects was also reduced. <code>FieldResult</code> is used for execution bookkeeping in some edge cases, but is often unneeded. So, we could optimize by removing the <code>FieldResult</code> object when we had a plain value (and therefore no bookkeeping was needed): <a href="https://github.com/rmosolgo/graphql-ruby/commit/07cbfa89031819d3886f220de8256e83ff59f298"><code>07cbfa89</code></a></p>

<p>A very modest optimization was also applied to <code>GraphQL::Arguments</code>, reusing the same object for empty argument lists (<a href="https://github.com/rmosolgo/graphql-ruby/pull/500/commits/4b07c9b46345144c7d88e429e7b55e09b0615517"><code>4b07c9b4</code></a>) and reusing the argument default values on a field-level basis (<a href="https://github.com/rmosolgo/graphql-ruby/pull/500/commits/4956149df0a4ab8a449679bcd9af20b3dad72585"><code>4956149d</code></a>).</p>

<h2>Avoid Duplicate Calculations</h2>

<p>Some elements of a GraphQL schema don&rsquo;t change during execution. As long as this holds true, we can cache the results of some calculations and avoid recalculating them.</p>

<p>A simple caching approach is to use a hash whose keys are the inputs and whose values are the cached outputs:</p>

<pre><code class="ruby"># Read-through cache for summing two numbers
#
# The first layer of the cache is the left-hand number:
read_through_sum = Hash.new do |hash1, left_num|
  # The second layer of the cache is the right-hand number:
  hash1[num1] = Hash.new do |hash2, right_num|

    # And finally, the result is stored as a value in the second hash:
    puts "Adding #{left_num} + #{right_num}"
    hash2[right_num] = left_num + right_num
  end
end

read_through_sum[1][2]
# "Adding 1 + 2"
# =&gt; 3

read_through_sum[1][2]
# =&gt; 3
</code></pre>

<p>The first lookup printed a message and returned a value but the second lookup did <em>not</em> print a value. This is because the block wasn&rsquo;t called. Instead, the cached value was returned immediately.</p>

<p>This approach was applied aggressively to <code>GraphQL::Schema::Warden</code>, an object which manages schema visibility on a query-by-query basis. Since the visibility of a schema member would remain constant during the query, we could cache the results of visibility checks: first <a href="https://github.com/rmosolgo/graphql-ruby/pull/462/commits/1a28b10494bf508519f8f9b4a1a589c458837cf7"><code>1a28b104</code></a>, then <a href="https://github.com/rmosolgo/graphql-ruby/pull/462/commits/27b36e89ca24b1dc8ec3e2d27612a6fb99039e54"><code>27b36e89</code></a>.</p>

<p>This was also applied to field lookup in <a href="https://github.com/rmosolgo/graphql-ruby/pull/402/commits/133ed1b1e0577df1db222a892d8afd95082c6d33"><code>133ed1b1e</code></a> and to <code>lazy_resolve</code> handler lookup in <a href="https://github.com/rmosolgo/graphql-ruby/pull/402/commits/283fc19d72eb9890ea6254f7fc79600f3f0bfbeb"><code>283fc19d</code></a>.</p>

<h2>Use <code>yield</code> Instead of <code>&amp;block</code></h2>

<p>Due to the implementation of Ruby&rsquo;s VM, calling a block with <a href="https://github.com/JuanitoFatas/fast-ruby#proccall-and-block-arguments-vs-yieldcode"><code>yield</code> is much faster than <code>block.call</code></a>. <code>@theorygeek</code> migrated <code>MiddlewareChain</code> to use that approach instead in <a href="https://github.com/rmosolgo/graphql-ruby/pull/462/commits/517cec3477097ddb05db0e02b6752be552d2e3dd"><code>517cec34</code></a>.</p>

<h2>Remove Overhead from Lazy Definition API (warning: terrible hack)</h2>

<p>In order to handle circular definitions, graphql-ruby&rsquo;s <code>.define { ... }</code> blocks aren&rsquo;t executed immediately. Instead, they&rsquo;re stored and evaluated only when a definition-dependent value is required. To achieve this, all definition-dependent methods were preceeded by a call to <code>ensure_defined</code>.</p>

<p>Maybe you remember that method from the <em>very top</em> of the profiler output above:</p>

<pre><code class="text"> %self      total      self      wait     child     calls  name
  4.60      0.074     0.022     0.000     0.052     6893  *Class#new
  3.99      0.019     0.019     0.000     0.000     8715  *GraphQL::Define::InstanceDefinable#ensure_defined
</code></pre>

<p>A fact about <code>GraphQL::Schema</code> is that, by the time it is defined, <em>all</em> lazy definitions have been executed. This means that during query execution, calling <code>ensure_defined</code> is <em>always</em> a waste!</p>

<p>I found a way to remove the overhead, but it was a huge hack. It works like this:</p>

<p>When a definition is added (with <code>.define</code>):</p>

<ul>
<li>store the definition block for later</li>
<li><p>find each definition-dependent method definition on the defined object and gather them into an array:</p>

<pre><code class="ruby">@pending_methods = method_names.map { |n| self.class.instance_method(n) }
</code></pre></li>
<li><em>replace</em> those methods with dummy methods which:

<ul>
<li>call <code>ensure_defined</code></li>
<li>re-apply all <code>@pending_methods</code>, overriding the dummy methods</li>
<li>call the <em>real</em> method (which was just re-applied)</li>
</ul>
</li>
</ul>


<p>This way, subsequent calls to definition-dependent methods <em>don&rsquo;t</em> call <code>ensure_defined</code>. <code>ensure_defined</code> removed itself from the class definition after its work was done!</p>

<p>You can see the whole hack in <a href="https://github.com/rmosolgo/graphql-ruby/pull/483/commits/18d73a58314cab96c28a9861506b6ad18c8df3aa"><code>18d73a58</code></a>. For all my teasing, this is something that makes Ruby so powerful: if you can imagine it, you can code it!</p>

<h2>The Final Product</h2>

<p>Two minor releases later, the profile output is looking better! Here&rsquo;s the output on master:</p>

<pre><code class="text">Thread ID: 70178713115080
Fiber ID: 70178720382840
Total: 0.310395
Sort by: self_time

 %self      total      self      wait     child     calls  name
  4.06      0.013     0.013     0.000     0.000     7644   Kernel#hash
  2.93      0.021     0.009     0.000     0.012     2917  *Class#new
  2.89      0.009     0.009     0.000     0.000     4184   GraphQL::Query::Context::FieldResolutionContext#query
  2.74      0.009     0.009     0.000     0.000    13542   Module#===
  2.60      0.008     0.008     0.000     0.000     1960   GraphQL::Query::Context::FieldResolutionContext#initialize
  2.27      0.013     0.007     0.000     0.006     1748   GraphQL::Query#arguments_for
  2.25      0.010     0.007     0.000     0.003     7523   Kernel#===
  2.14      0.022     0.007     0.000     0.015     1959   GraphQL::Query::Context::FieldResolutionContext#spawn
  2.09      0.007     0.007     0.000     0.000     8260   Kernel#is_a?
  1.87      0.039     0.006     0.000     0.033     1748   GraphQL::Schema::RescueMiddleware#call
  1.75      0.013     0.005     0.000     0.008     1748   GraphQL::Execution::Lazy::LazyMethodMap#get
  1.69      0.005     0.005     0.000     0.000     2259   Kernel#class
  1.68      0.044     0.005     0.000     0.039     3496  *GraphQL::Schema::MiddlewareChain#invoke_core
  1.33      0.004     0.004     0.000     0.000     1747   GraphQL::Query::Context::FieldResolutionContext#schema
  1.31      0.029     0.004     0.000     0.025     1748   &lt;Module::GraphQL::Execution::Execute::FieldResolveStep&gt;#call
  1.20      0.004     0.004     0.000     0.000     1748   GraphQL::Execution::SelectionResult#set
  1.15      0.048     0.004     0.000     0.044     1748   GraphQL::Schema::MiddlewareChain#invoke
  1.14      0.017     0.004     0.000     0.013     1748   GraphQL::Schema#lazy_method_name
  1.07      0.004     0.003     0.000     0.001     1044   Kernel#public_send
  1.05      0.020     0.003     0.000     0.017     1748   GraphQL::Schema#lazy?
  1.02      0.004     0.003     0.000     0.000     1806   GraphQL::InternalRepresentation::Node#definition
</code></pre>

<p>Here are the wins:</p>

<ul>
<li>Object allocations reduced by 58%</li>
<li>Method calls to gem code and Ruby built-ins reduced by &hellip; a lot!</li>
<li>Calls to <code>ensure_defined</code> reduced by 100% üòÜ</li>
</ul>


<p>And, as shown in the benchmark above, 1.7x faster query execution!</p>

<p>There&rsquo;s one caveat: these optimization apply to the GraphQL runtime <em>only</em>. <em>Real</em> GraphQL performance depends on more than that. It includes application-specific details like database access, remote API calls and application code performance.</p>
]]></content>
  </entry>
  
</feed>
