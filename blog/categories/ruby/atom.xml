<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Robert Mosolgo]]></title>
  <link href="http://rmosolgo.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://rmosolgo.github.io/"/>
  <updated>2017-10-06T09:28:00-04:00</updated>
  <id>http://rmosolgo.github.io/</id>
  <author>
    <name><![CDATA[Robert Mosolgo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Type Checking Roundup]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/10/06/ruby-type-checking-roundup/"/>
    <updated>2017-10-06T09:00:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/10/06/ruby-type-checking-roundup</id>
    <content type="html"><![CDATA[<p>This fall, several people presented their work on Ruby type checkers. So let&rsquo;s take a look: what&rsquo;s the big deal, and what have they been up to?</p>

<!-- more -->


<h2>Why Type Check?</h2>

<p>Part of Ruby&rsquo;s appeal is to be <em>free</em> of the cruft of its predecessors. So why is there so much interest in <em>adding</em> types to Ruby?</p>

<ul>
<li>Large, sprawling projects are becoming more common. At Ruby&rsquo;s inception, there were no 10-year-old Rails apps which people struggled to maintain, only greenfield Ruby scripts for toy projects.</li>
<li>Programmers have experienced excellent type systems in other languages, and want those benefits in Ruby.</li>
<li><em>Optional</em>, gradual type systems have been introduced to Python and JavaScript and they&rsquo;re big successes.</li>
</ul>


<p>What are the benefits?</p>

<ul>
<li><strong>Correctness</strong>: Type checking, like testing, is a way to be confident that your codebase is functioning properly. Employing a type checker can help you find bugs during development and prevent those bugs from going to production.</li>
<li><strong>Confidence</strong>: Since an incorrect program won&rsquo;t pass type checking, developers can refactor with more confidence. Common errors such as typos and argument errors can be caught by the type checker.</li>
<li><strong>Design</strong>: The type system gives you a way to think about the program. Specifically, types document and define the <em>boundaries</em> between parts of code, like methods, classes and modules.</li>
</ul>


<p>To experience a great type system in a Ruby-like language, I recommend <a href="https://crystal-lang.org/">Crystal</a>.</p>

<h2>Jeff Foster, StrangeLoop 2017</h2>

<p><a href="http://www.cs.umd.edu/~jfoster/">Jeff Foster</a> is a professor at the <a href="http://www.umd.edu/">University of Maryland, College Park</a> and works in the <a href="http://www.cs.umd.edu/projects/PL/">programming languages group</a>. Along with his students, he&rsquo;s been exploring Ruby type checkers for <strong>nine years</strong>! This year, he gave a presentation at StrangeLoop, <a href="https://www.youtube.com/watch?v=buY54I7mEjA">Type Checking Ruby</a>.</p>

<p>He described his various avenues of research over the years, and how they influenced one another, leading to a final question:</p>

<pre><code class="ruby">class Talk &lt; ActiveRecord::Base
  belongs_to :owner, class_name: "User"

  def owner?(other_user)
    # QUESTION
    # How to know the type of `#owner` method at this point?
    owner == other_user
  end
end
</code></pre>

<p>His early work revolved around <em>static</em> type checking: annotations in the source code were given to a type checker, which used those annotations to assert that the Ruby code was correct.</p>

<p>This approach had a fundamental limitation: how can dynamically-created methods (like <code>Talk#owner</code> above) be statically annotated?</p>

<p>This drove him and his team to develop <a href="https://github.com/plum-umd/rdl">RDL</a>, a <em>dynamic</em> type checker. In RDL, types are declared using <em>methods</em> instead of annotations, for example:</p>

<pre><code class="ruby">type '(Integer, Integer) -&gt; Integer'
def multiply(x, y)
  x * y
end
</code></pre>

<p>By using methods, it handles metaprogramming in a straightforward way. It hooks into Rails' <code>.belongs_to</code> and adds annotations for the generated methods, for example:</p>

<pre><code class="ruby"># Rails' belongs_to method
def belongs_to(name, options = {})
  # ...
  # define a reader method, like `Talk#owner` above
  type "() -&gt; #{class_name}"
  define_method(name) do
    # ...
  end
end
</code></pre>

<p>(In reality, RDL uses <a href="https://github.com/plum-umd/rdl#preconditions-and-postconditions">conditions</a>, not monkey-patching, to achieve this.)</p>

<p>In this approach, type information is <em>gathered while the program runs</em>, but the typecheck is deferred until the method is called. At that point, RDL checks the source code (static information) using the runtime data (dynamic information). For this reason, RDL is called &ldquo;Just-in-Time Static Type Checking.&rdquo;</p>

<p>You can learn more about RDL in several places:</p>

<ul>
<li>RDL on GitHub: <a href="https://github.com/plum-umd/rdl">https://github.com/plum-umd/rdl</a></li>
<li>StrangeLoop 2017 talk: <a href="https://www.youtube.com/watch?v=buY54I7mEjA">https://www.youtube.com/watch?v=buY54I7mEjA</a></li>
<li>Academic papers from the folks behind RDL: <a href="https://github.com/plum-umd/rdl#bibliography">https://github.com/plum-umd/rdl#bibliography</a></li>
</ul>


<p>Personally, I can&rsquo;t wait to take RDL for a try. At the conference, Jeff mentioned that <em>type inference</em> was on his radar. That would take RDL to the next level!</p>

<p>Not to read into it too far, but it looks like <a href="https://github.com/plum-umd/rdl/issues/40#issuecomment-329135921">Stripe is exploring RDL</a> 😎.</p>

<h2>Soutaro Matsumoto, RubyKaigi 2017</h2>

<p>Soutaro Matsumoto also has significant academic experience with type checking Ruby, and this year, he presented some of his work at RubyKaigi in <a href="https://youtu.be/JExXdUux024">Type Checking Ruby Programs with Annotations</a>.</p>

<p>He begins with an overview of type checking Ruby, and surveys the previous work in type inference. He also points out how requirements should be relaxed for Ruby:</p>

<ul>
<li><strong><del>Correctness</del> -> Forget correctness</strong> (Allow a mix of typed and untyped code, so that developers can work quickly when they don&rsquo;t want or need types.)</li>
<li><strong><del>Static</del> -> Defer type checking to runtime</strong> (He mentions RDL in this context)</li>
<li><strong><del>No annotations</del> -> Let programmers write types</strong> (<em>Completely</em> inferring types is not possible, so accept some hints from the developers.)</li>
</ul>


<p>Then, he introduces his recent project, <a href="https://github.com/soutaro/steep">Steep</a>.</p>

<p>Steep&rsquo;s approach is familiar, but new to Ruby. It has three steps:</p>

<ul>
<li>Write a <code>.rbi</code> file which describes the types in your program, using a special type language, for example:</li>
</ul>


<pre><code class="ruby">class Talk {
  def owner: (User) -&gt; _Boolean
}
</code></pre>

<ul>
<li>Add annotations to your Ruby code to connect it to your types:</li>
</ul>


<pre><code class="ruby">class Talk &lt; ActiveRecord::Base
  belongs_to :owner, class_name: "User"
  # @dynamic owner
end
</code></pre>

<p>  Some connections between Ruby source and the <code>.rbi</code> files can be made automatically; others require explicit annotations.</p>

<ul>
<li><p>Run the type checker:</p>

<pre><code>$ steep check app/models/talk.rb
</code></pre></li>
</ul>


<p>It reminds me a bit of the <code>.h</code>/<code>.c</code> files in a C project.</p>

<p>Soutaro is also presenting his work at <a href="http://rubyconf.org/program#session-233">this winter&rsquo;s RubyConf</a>.</p>

<h2>Valentin Fondaratov, RubyKaigi 2017</h2>

<p>Valentin works at JetBrains (creators of <a href="https://www.jetbrains.com/ruby/">RubyMine</a>) and presented his work on type-checking based on <em>runtime</em> data. His presentation, <a href="https://www.youtube.com/watch?v=JS6m2gke0Ic">Automated Type Contracts Generation for Ruby</a>, was really fascinating and offered a promising glimpse of what a Ruby type ecosystem could be.</p>

<p>Valentin started by covering RubyMine&rsquo;s current type checking system:</p>

<ul>
<li>RubyMine tries to resolve identifiers (eg, method names, constant names) to their implementations</li>
<li>But this is hard: given <code>obj.execute</code>, what method does it call?</li>
<li>Developers can provide hints with YARD documentation</li>
<li>RubyMine uses this to support autocomplete, error prediction, and rename refactorings</li>
</ul>


<p>He also pointed out that even code coverage is not enough: 100% code coverage does <em>not</em> guarantee that all <em>possible</em> codepaths were run. For example, any composition of <code>if</code> branches require a cross-product of codepaths, not only that each line is executed once. Besides that, code coverage does <em>not</em> analyze the coverage of your dependencies' code (ie, RubyGems).</p>

<p>So, Valentin suggests getting <em>more</em> from our unit tests: what if we <em>observed</em> the running program, and kept notes about what values were passed around and how they were used? In this arrangement, that <em>runtime</em> data could be accumulated, then used for type checking.</p>

<p>Impressively, he introduced the implementation of this, first using a <a href="ruby-doc.org/core-2.4.0/TracePoint.html">TracePoint</a>, then digging into the Ruby VM to get even more granular data.</p>

<p>However, the gathered data can be very complicated. For example, how can we understand the input type of <code>String#split</code>?</p>

<pre><code class="ruby"># A lot of type checking data generated at runtime:
# call                                # Input type
"1,2,,3,4,,".split(",")               # (String, nil)
# =&gt; ["1", "2", "", "3", "4"]
"1,2,,3,4,,".split(",", 4)            # (String, Integer)
# =&gt; ["1", "2", "", "3,4,,"]
"1,2,,3,4,,".split(",", -4)           # (String, Integer)
# =&gt; ["1", "2", "", "3", "4", "", ""]
"1,2,,3,4,,".split(/\d/)              # (Regexp, nil)
# =&gt; ["", ",", ",,", ",", ",,"]
# ...
</code></pre>

<p>Valentin showed how a classic technique, finite automata, can be used to reduce this information to a useful data structure.</p>

<p>Then, this runtime data can be used to <em>generate</em> type annotations (as YARD docs).</p>

<p>Finally, he imagines a type ecosystem for Ruby:</p>

<ul>
<li>Users contribute their (anonymized) runtime information for their RubyGem depenedencies</li>
<li>This data is pooled into a shared database, merged by RubyGem &amp; version</li>
<li>Users can draw type data <em>from</em> the shared database</li>
</ul>


<p>Personally, I think this is a great future to pursue:</p>

<ul>
<li>Developers can <em>gain</em> type checking without any annotations</li>
<li>Annotations can become very robust because resources are shared</li>
<li><em>Real</em> 100% coverage is possible via community collaboration</li>
</ul>


<p>You can see the project on GitHub: <a href="https://github.com/JetBrains/ruby-type-inference">https://github.com/JetBrains/ruby-type-inference</a></p>

<h2>Summary</h2>

<p>There&rsquo;s a lot of technically-savvy and academically-informed work on type checking Ruby! Many of the techniques preserve Ruby&rsquo;s productivity and dynamism while improving the developer experience and confidence. What makes them unique is their use of <em>runtime</em> data, to observe the program in action, then make assertions about the source code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What's new in React-Rails 2.0?]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/04/13/whats-new-in-react-rails-2-dot-0/"/>
    <updated>2017-04-13T11:59:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/04/13/whats-new-in-react-rails-2-dot-0</id>
    <content type="html"><![CDATA[<p>For <a href="http://planning.center">Planning Center</a> free week, I cooked up <a href="https://github.com/reactjs/react-rails"><code>react-rails</code></a> 2.0 🎊.</p>

<!-- more -->


<p>Here are a few highlights. For the full list, see the <a href="https://github.com/reactjs/react-rails/blob/master/CHANGELOG.md">changelog</a>!</p>

<h2>Webpacker support</h2>

<p><a href="https://github.com/rails/webpacker">Webpacker</a> was great to work with. <code>react-rails</code> now supports webpacker for:</p>

<ul>
<li>Mounting components with <code>&lt;%= react_component(...) %&gt;</code> via <code>require</code></li>
<li>Server rendering from a webpacker pack (<code>server_rendering.js</code>)</li>
<li>Loading the unobtrusive JavaScript (UJS)</li>
<li>Installation and component generators</li>
</ul>


<p>A nice advantage of using webpacker is that you can load React.js from NPM instead of the <code>react-rails</code> gem. This way, you aren&rsquo;t bound to the React.js version which is included with the Ruby gem. You can pick any version you want!</p>

<h2>UJS on npm</h2>

<p>To support frontends built with Node.js, <code>react-rails</code>&rsquo;s  UJS driver is available on NPM as <a href="https://www.npmjs.com/package/react_ujs"><code>react_ujs</code></a>. It performs setup during <code>require</code>, so these two are equal:</p>

<pre><code class="js">// Sprockets:
//= require react_ujs

// Node, etc:
require("react_ujs")
</code></pre>

<h2>Request-based prerender context</h2>

<p>If you&rsquo;re prerendering your React components on the server, you can perform setup and teardown in your Rails controller. For example, you might use these hooks to populate a flux store.</p>

<p>First, add the <code>per_request_react_rails_prerenderer</code> helper to your controller:</p>

<pre><code class="ruby">class PagesController &lt; ApplicationController
  per_request_react_rails_prerenderer
  # ...
end
</code></pre>

<p>Then, you can access <code>react_rails_prerenderer</code> in the controller action:</p>

<pre><code class="ruby">def show
  js_context = react_rails_prerenderer.context
  js_context.exec(js_setup_code)
  render :show
  js_context.exec(js_teardown_code)
end
</code></pre>

<p>That way, you can properly prepare &amp; clean up a JS VM for server rendering.</p>

<h2>Re-detect events</h2>

<p>Previously, <code>ReactRailsUJS</code> &ldquo;automatically&rdquo; detected which libraries you were using and hooked up to their events for rendering components.</p>

<p>It still checks for libraries during its initial load, but you can <em>also</em> re-check as needed:</p>

<pre><code class="js">// Check the global context for libraries like Turbolinks and hook up to them:
ReactRailsUJS.detectEvents()
</code></pre>

<p>This function removes previous event handlers, so it&rsquo;s safe to call anytime. (This was added in <code>2.0.2</code>.)</p>

<h2>Other Takeaways</h2>

<p>See the <a href="https://github.com/reactjs/react-rails/blob/master/CHANGELOG.md">changelog</a> for bug fixes and a new default server rendering configuration.</p>

<p>Webpacker is great! Setup was smooth and the APIs were clear and convenient. I&rsquo;m looking forward to using it more.</p>

<p>🍻 Here&rsquo;s to another major version of <code>react-rails</code>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Watching files during Rails development]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/04/12/watching-files-during-rails-development/"/>
    <updated>2017-04-12T14:09:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/04/12/watching-files-during-rails-development</id>
    <content type="html"><![CDATA[<p>You can tell Ruby on Rails to respond to changes in certain files during development.</p>

<!-- more -->


<p>Rails knows to watch <code>config/routes.rb</code> for changes and reload them when the files change. You can use the same mechanism to watch other files and take action when they change.</p>

<p>I used this feature for <a href="https://github.com/reactjs/react-rails">react-rails</a> server rendering and for <a href="http://graphql.pro">GraphQL::Pro</a> static queries.</p>

<h2>app.reloader</h2>

<p>Every Rails app has <a href="https://github.com/rails/rails/blob/8f59a1dd878f56798f88369fa5b448f17a29679d/railties/lib/rails/application.rb#L135">a <code>@reloader</code></a>, which is a local subclass of <a href="http://api.rubyonrails.org/classes/ActiveSupport/Reloader.html"><code>ActiveSupport::Reloader</code></a>. It&rsquo;s used whenever you call <a href="https://github.com/rails/rails/blob/fe1f4b2ad56f010a4e9b93d547d63a15953d9dc2/railties/lib/rails/console/app.rb#L29-L34"><code>reload!</code> in the Rails console</a>.</p>

<p>It&rsquo;s attached to a <a href="https://github.com/rails/rails/blob/d3c9d808e3e242155a44fd2a89ef272cfade8fe8/railties/lib/rails/application/default_middleware_stack.rb#L51-L53">rack middleware</a> which <a href="https://github.com/rails/rails/blob/d3c9d808e3e242155a44fd2a89ef272cfade8fe8/actionpack/lib/action_dispatch/middleware/executor.rb#L10">calls <code>#run!</code></a> (which, in turn, <a href="https://github.com/rails/rails/blob/291a098c111ff419506094e14c0186389b0020ca/activesupport/lib/active_support/reloader.rb#L57-L63">calls the reload blocks if it detects changes</a>).</p>

<h2>config.to_prepare</h2>

<p>You can add custom preparation hooks with <code>config.to_prepare</code>:</p>

<pre><code class="ruby">initializer :my_custom_preparation do |app|
  config.to_prepare do
    puts "Reloading now ..."
  end
end
</code></pre>

<p>When Rails detects a change, this block will be called. It&rsquo;s implemented by <a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L53-L55">registering the block with <code>app.reloader</code></a>.</p>

<h2>app.reloaders</h2>

<p>To add <em>new conditions</em> for which Rails should reload, you can add to the <a href="https://github.com/rails/rails/blob/8f59a1dd878f56798f88369fa5b448f17a29679d/railties/lib/rails/application.rb#L126"><code>app.reloaders</code> array</a>:</p>

<pre><code class="ruby"># Object responds to `#updated?`
class MyWatcher
  def updated?
    # ...
  end
end

# ...

initializer :my_custom_watch_condition do |app|
  # Register custom reloader:
  app.reloaders &lt;&lt; MyWatcher.new
end
</code></pre>

<p>The object&rsquo;s <a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L156-L158"><code>updated?</code> method will be called</a> by the reloader. If any reloader returns <code>true</code>, the middleware will run all <code>to_prepare</code> blocks (via the call to <code>@reloader.run!</code>).</p>

<h2>FileUpdateChecker</h2>

<p>Rails includes a goodie for watching files. <a href="http://api.rubyonrails.org/classes/ActiveSupport/FileUpdateChecker.html"><code>ActiveSupport::FileUpdateChecker</code></a> is great for:</p>

<ul>
<li>Watching specific files for changes (<a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/routes_reloader.rb#L41"><code>config/routes.rb</code> is watched this way</a>)</li>
<li>Watching a directory of files for changes, additions and deletions (<a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L164"><code>app/**/*.rb</code> is watched this way</a>)</li>
</ul>


<p>You can create your own <code>FileUpdateChecker</code> and add it to <code>app.reloaders</code> to reload Rails when certain files change:</p>

<pre><code class="ruby"># Watch specific files:
app.reloaders &lt;&lt; ActiveSupport::FileUpdateChecker.new(["my_important_file.txt", "my_other_important_file.txt"])
# Watch directory-extension pairs, eg all `.txt` and `.md` files in `app/important_files` and subdirectories:
app.reloaders &lt;&lt; ActiveSupport::FileUpdateChecker([], { "app/important_files" =&gt; [".txt", ".md"] })
</code></pre>

<p>Some filesystems support an evented file watcher implementation, <a href="http://api.rubyonrails.org/classes/ActiveSupport/EventedFileUpdateChecker.html"><code>ActiveSupport::EventedFileUpdateChecker</code></a>. <code>app.config.file_watcher</code> will return the proper filewatcher class for the current context.</p>

<pre><code class="ruby">app.reloaders &lt;&lt; app.config.file_watcher(["my_important_file.txt", "my_other_important_file.txt"])
</code></pre>

<h2>All Together Now</h2>

<p><code>react-rails</code> maintains a pool of V8 instances for server rendering React components. These instances are initialized with a bunch of JavaScript code, and whenever a developer changes a JavaScript file, we need to reload them with the new code. This requires two steps:</p>

<ul>
<li>Adding a new watcher to <code>app.reloaders</code> to detect changes to JavaScript files</li>
<li>Adding a <code>to_prepare</code> hook to reload the JS instances</li>
</ul>


<p>It looks basically like this:</p>

<pre><code class="ruby">initializer "react_rails.watch_js_files" do |app|
  # Watch for changes to javascript files:
  app.reloaders &lt;&lt; app.config.file_watcher.new([], {
    # Watch the asset pipeline:
    Rails.root.join("app/assets/javascripts").to_s =&gt; ["jsx", "js"],
    # Watch webpacker:
    Rails.root.join("app/javascript").to_s =&gt; ["jsx", "js"]
  })

  config.to_prepare do
    React::ServerRendering.reset_pool
  end
end
</code></pre>

<p>The <a href="https://github.com/reactjs/react-rails/blob/bbb1ff10c787ca6a186e39df57fe5b228b37bd7e/lib/react/rails/railtie.rb#L26-L39">full implementation</a> supports some customization. You can see similar (and more complicated) examples with <a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L126-L142">routes reloading</a>, <a href="https://github.com/rails/rails/blob/e9abbb700acd8165a8994d8b2a700e507fb3b7ff/activesupport/lib/active_support/i18n_railtie.rb#L59-L74">i18n reloading</a> and <a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L163-L183"><code>.rb</code> reloading</a>.</p>

<p>Happy reloading!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prototyping a GraphQL Schema From Definition With Ruby]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/03/17/prototyping-a-graphql-schema-from-definition-with-ruby/"/>
    <updated>2017-03-17T15:49:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/03/17/prototyping-a-graphql-schema-from-definition-with-ruby</id>
    <content type="html"><![CDATA[<p>GraphQL 1.5.0 includes a new way to define a schema: from a GraphQL definition.</p>

<!-- more -->


<p>In fact, loading a schema this way has been supported for while, but 1.5.0 adds the ability to specify field resolution behavior.</p>

<h2>GraphQL IDL</h2>

<p>Besides queries, GraphQL has an <em>interface definition language</em> (IDL) for expressing a schema’s structure. For example:</p>

<pre><code class="ruby">schema {
  query: Query
}

type Query {
  post(id: ID!): Post
}

type Post {
  title: String!
  comments: [Comment!]
}
</code></pre>

<p>You can turn a definition into a schema with <code>Schema.from_definition</code>:</p>

<pre><code class="ruby">schema_defn = "..."
schema = GraphQL::Schema.from_definition(schema_defn)
</code></pre>

<p>(By the way, the IDL is technically in <a href="https://github.com/facebook/graphql/pull/90">RFC stage</a>.)</p>

<h2>Resolvers</h2>

<p><code>Schema.from_definition</code> also accepts <code>default_resolve:</code> argument. It expects one of two inputs:</p>

<ul>
<li>A nested hash of type <code>Hash&lt;String =&gt; Hash&lt;String =&gt; #call(obj, args, ctx)&gt;&gt;</code>; or</li>
<li>An object that responds to <code>#call(type, field, obj, args, ctx)</code></li>
</ul>


<h4>Resolving with a Hash</h4>

<p>When you’re using a hash:</p>

<ul>
<li>The first key is a <em>type name</em></li>
<li>The second key is a <em>field name</em></li>
<li>The last value is a <em>resolve function</em> (<code>#call(obj, args, ctx)</code>)</li>
</ul>


<p>To get started, you can write the hash manually:</p>

<pre><code class="ruby">{
  "Query" =&gt; {
    "post" =&gt; -&gt;(obj, args, ctx) { Post.find(args[:id]) },
  },
  "Post" =&gt; {
    "title" =&gt; -&gt;(obj, args, ctx) { obj.title },
    "body" =&gt; -&gt;(obj, args, ctx) { obj.body },
    "comments" =&gt; -&gt;(obj, args, ctx) { obj.comments },
  },
}
</code></pre>

<p>But you can also reduce a lot of boilerplate by using a hash with default values:</p>

<pre><code class="ruby"># This hash will fall back to default implementation if another value isn't provided:
type_hash = Hash.new do |h, type_name|
  # Each type gets a hash of fields:
  h[type_name] = Hash.new do |h2, field_name|
    # Default resolve behavior is `obj.public_send(field_name, args, ctx)`
    h2[field_name] = -&gt;(obj, args, ctx) { obj.public_send(field_name, args, ctx) }
  end
end

type_hash["Query"]["post"] = -&gt;(obj, args, ctx) { Post.find(args[:id]) }

schema = GraphQL::Schema.from_definition(schema_defn, default_resolve: type_hash)
</code></pre>

<p>Isn’t that a nice way to set up a simple schema?</p>

<h4>Resolving with a Single Function</h4>

<p>You can provide a single callable that responds to <code>#call(type, field, obj, args, ctx)</code>. What a mouthful!</p>

<p>The <em>advantage</em> of that hefty method signature is that it’s enough to specify any resolution behavior you can imagine. For example, you could create a system where type modules were found by name, then methods were called by name:</p>

<pre><code class="ruby">module ExecuteGraphQLByConvention
  module_function
  # Find a Ruby module corresponding to `type`,
  # then call its method corresponding to `field`.
  def call(type, field, obj, args, ctx)
    type_module = Object.const_get(type.name)
    type_module.public_send(field.name, obj, args, ctx)
  end
end

schema = GraphQL::Schema.from_definition(schema_defn, default_resolve: ExecuteGraphQLByConvention)
</code></pre>

<p>So, a single function combined with Ruby’s flexibility and power opens a lot of doors!</p>

<p>Doesn’t it remind you a bit of method dispatch? The arguments are:</p>

<table>
<thead>
<tr>
<th>GraphQL Field Resolution </th>
<th> Method Dispatch</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>type</code> </td>
<td> class</td>
</tr>
<tr>
<td><code>field</code> </td>
<td> method</td>
</tr>
<tr>
<td><code>obj</code> </td>
<td> receiver</td>
</tr>
<tr>
<td><code>args</code> </td>
<td> method arguments</td>
</tr>
<tr>
<td><code>ctx</code> </td>
<td> runtime state (cf <a href="https://github.com/mruby/mruby/blob/master/include/mruby.h#L257"><code>mrb_state</code></a>, <a href="https://github.com/antirez/redis/blob/unstable/src/modules/INTRO.md"><code>RedisModuleCtx</code></a>, or <a href="http://erlang.org/doc/tutorial/nif.html"><code>ErlNifEnv</code></a>)</td>
</tr>
</tbody>
</table>


<h2>Special Configurations</h2>

<p>Some schemas need other configurations in order to run:</p>

<ul>
<li><code>resolve_type</code> to support union and interface types</li>
<li>schema plugins like <a href="https://rmosolgo.github.io/graphql-ruby/pro/monitoring">monitoring</a> or custom <a href="https://rmosolgo.github.io/graphql-ruby/schema/instrumentation">instrumentation</a></li>
</ul>


<p>To add these to a schema, use <code>.redefine</code>:
```ruby</p>

<h1>Extend the schema with new definitions:</h1>

<p>schema = schema.redefine {
  resolve_type ->(obj, ctx) { &hellip; }
  monitoring :appsignal
}
```</p>

<h2>What’s Next?</h2>

<p>Rails has proven that “Convention over Configuration” can be a very productive way to start new projects, so I’m interested in exploring convention-based APIs on top of this feature.</p>

<p>In the future, I’d like to add support for schema annotations in the form of directives, for example:</p>

<pre><code class="ruby">type Post {
  comments: [Comment!] @relation(hasMany: "comments")
}
</code></pre>

<p>These could be used to customize resolution behavior. Cool!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tracking Schema Changes with GraphQL-Ruby]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/03/16/tracking-schema-changes-with-graphql-ruby/"/>
    <updated>2017-03-16T20:16:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/03/16/tracking-schema-changes-with-graphql-ruby</id>
    <content type="html"><![CDATA[<p>One way to keep an eye on your GraphQL schema is to check the definition into source control.</p>

<!-- more -->


<p>When modifying shared code or reconfiguring, it can be hard to tell how the schema will <em>really</em> change. To help with this, set up a <strong>snapshot test</strong> for your GraphQL schema! This way:</p>

<ul>
<li>Changes will be clearly visible in GraphQL IDL</li>
<li>You can keep the IDL up-to-date by adding a test to your suite</li>
</ul>


<p>You can even track the schema from different contexts if you&rsquo;re using <a href="https://rmosolgo.github.io/graphql-ruby/pro/authorization"><code>GraphQL::Pro</code>&rsquo;s authorization framework</a>.</p>

<p>This approach was first described in <a href="https://www.youtube.com/watch?v=Wlu_PWCjc6Y">GraphQL at Shopify</a>.</p>

<h2>Check It In</h2>

<p>Write a <strong>Rake task</strong> to get your schema&rsquo;s definition and write it to a file:</p>

<pre><code class="ruby"># lib/tasks/graphql.rake
rake dump_schema: :environment do
  # Get a string containing the definition in GraphQL IDL:
  schema_defn = MyAppSchema.to_definition
  # Choose a place to write the schema dump:
  schema_path = "app/graphql/schema.graphql"
  # Write the schema dump to that file:
  File.write(Rails.root.join(schema_path), schema_defn)
  puts "Updated #{schema_path}"
end
</code></pre>

<p>You can run it from terminal:</p>

<pre><code class="sh">$ bundle exec rake dump_schema
Updated app/graphql/schema.graphql
</code></pre>

<p>This updates the file in your repo. Go ahead and <strong>check it in</strong>!</p>

<pre><code class="sh">$ git add app/graphql/schema.graphql
$ git commit -m "Add GraphQL schema dump"
</code></pre>

<h2>Keep It Up to Date</h2>

<p>Any changes to the Ruby schema code must be reflected in the <code>.graphql</code> file. You can give yourself a reminder by adding a <strong>test case</strong> which asserts that the GraphQL definition is up-to-date:</p>

<pre><code class="ruby"># test/graphql/my_app_schema_test.rb
require "test_helper"

class MyAppSchemaTest &lt; ActiveSupport::TestCase
  def test_printout_is_up_to_date
    current_defn = MyAppSchema.to_definition
    printout_defn = File.read(Rails.root.join("app/graphql/schema.graphql"))
    assert_equal(current_defn, printout_defn, "Update the printed schema with `bundle exec rake dump_schema`")
  end
end
</code></pre>

<p>If the definition is stale, you&rsquo;ll get a failed test:</p>

<p><img src="/images/tracking_schema/test_failure.png" width="500"></p>

<p>This reminder is helpful in development and <em>essential</em> during code review!</p>

<h2>Review It</h2>

<p>Now that your schema definition is versioned along with your code, you can see changes during <strong>code review</strong>:</p>

<p><img src="/images/tracking_schema/code_review.png" width="600"></p>

<h2>Multiple Schema Dumps</h2>

<p>If your schema looks different to different users, you can track <em>multiple</em> schema dumps. This is helpful if:</p>

<ul>
<li>You&rsquo;re using the <code>:view</code> configuration of <a href="https://rmosolgo.github.io/graphql-ruby/pro/authorization"><code>GraphQL::Pro</code>&rsquo;s authorization</a></li>
<li>You&rsquo;re using <code>only:</code>/ <code>except:</code> to manually filter your schema</li>
</ul>


<p>Just provide the <code>context:</code> argument to <code>Schema.to_definition</code> as if you were running a query. (Also provide <code>only:</code>/<code>except:</code> if you use them.)</p>

<p>Print with a filter from the Rake task:</p>

<pre><code class="ruby"># lib/tasks/graphql.rake
task dump_schema: :environment do
  # ...
  admin_user = OpenStruct.new(admin?: true)
  admin_schema_dump = MyAppSchema.to_definition(context: { current_user: admin_user })
  admin_schema_path = "app/graphql/admin_schema.graphql"
  File.write(Rails.root.join(admin_schema_path), admin_schema_dump)
end
</code></pre>

<p>Test with a filter from the test case:</p>

<pre><code class="ruby">def test_printout_is_up_to_date
  # ...
  admin_user = OpenStruct.new(admin?: true)
  current_admin_defn = MyAppSchema.to_definition(context: { current_user: admin_user })
  printout_admin_defn = File.read(Rails.root.join("app/graphql/admin_schema.graphql"))
  assert_equal(current_admin_defn, printout_admin_defn, "Update the printed schema with `bundle exec rake dump_schema`")
end
</code></pre>

<p>Now you can keep an eye on the schema from several perspectives!</p>
]]></content>
  </entry>
  
</feed>
