<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | Robert Mosolgo]]></title>
  <link href="http://rmosolgo.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://rmosolgo.github.io/"/>
  <updated>2018-05-21T14:41:21-04:00</updated>
  <id>http://rmosolgo.github.io/</id>
  <author>
    <name><![CDATA[Robert Mosolgo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How Ripper parses variables]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/05/21/how-ripper-parses-variables/"/>
    <updated>2018-05-21T14:11:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/05/21/how-ripper-parses-variables</id>
    <content type="html"><![CDATA[<p>Ruby has a few different kinds of variables, and Ripper expresses them with a few different nodes.</p>

<!-- more -->


<p>Here are the different variables in Ruby:</p>

<pre><code class="ruby">a   # Local variable (or method call on self)
$a  # Global variable
A   # Constant
@a  # Instance variable
@@a # Class variable

# Bonus, not variables:
a()       # explicit method call (with parens) on implicit self
a b       # explicit method call (with args) on implicit self
self.a    # explicit method call (with dot) on explicit self
</code></pre>

<p>Here is how Ripper parses the above code:</p>

<pre><code class="ruby"># Ripper.sexp_raw(...) =&gt;

[:program,
 [:stmts_add,
  [:stmts_add,
   [:stmts_add,
    [:stmts_add,
     [:stmts_add,
      [:stmts_add,
       [:stmts_add,
        [:stmts_add, [:stmts_new], [:vcall, [:@ident, "a", [1, 0]]]],
        [:var_ref, [:@gvar, "$a", [2, 0]]]],
       [:var_ref, [:@const, "A", [3, 0]]]],
      [:var_ref, [:@ivar, "@a", [4, 0]]]],
     [:var_ref, [:@cvar, "@@a", [5, 0]]]],
    [:method_add_arg, [:fcall, [:@ident, "a", [8, 0]]], [:arg_paren, nil]]],
   [:command,
    [:@ident, "a", [9, 0]],
    [:args_add_block,
     [:args_add, [:args_new], [:vcall, [:@ident, "b", [9, 2]]]],
     false]]],
  [:call, [:var_ref, [:@kw, "self", [10, 0]]], :".", [:@ident, "a", [10, 5]]]]]
</code></pre>

<p>(<a href="https://ripper-preview.herokuapp.com/?code=a+++%23+Local+variable+%28or+method+call+on+self%29%0D%0A%24a++%23+Global+variable%0D%0AA+++%23+Constant%0D%0A%40a++%23+Instance+varaible%0D%0A%40%40a+%23+Class+variable%0D%0A%0D%0A%23+Bonus%2C+not+variables%3A%0D%0Aa%28%29+++++++%23+explicit+method+call+%28with+parens%29+on+implicit+self%0D%0Aself.a++++%23+explicit+method+call+%28with+dot%29+on+explicit+self">Ripper-preview</a>)</p>

<p>Let&rsquo;s check out those nodes.</p>

<h3>:vcall</h3>

<pre><code class="ruby"># a
[:vcall, [:@ident, "a", [1, 0]]]]
</code></pre>

<p>A <code>:vcall</code> is a bareword, either a local variable lookup <em>or</em> a method call on self. Used alone, this can only be determined at runtime, depending on the binding. If there&rsquo;s a local variable, it will be used. My guess is that <code>:vcall</code> is short for &ldquo;variable/call&rdquo;</p>

<p>Interestingly, there is a single-expression case which <em>could</em> be disambiguated statically, but Ripper still uses <code>:vcall</code>:</p>

<pre><code class="ruby"># a b
[:command,
 [:@ident, "a", [1, 0]],
 [:args_add_block,
  [:args_add, [:args_new], [:vcall, [:@ident, "b", [1, 2]]]],
  false]]]]
</code></pre>

<h3>:var_ref</h3>

<pre><code class="ruby"># $a
[:var_ref, [:@gvar, "$a", [1, 0]]]
# A
[:var_ref, [:@const, "A", [1, 0]]]
# @a
[:var_ref, [:@ivar, "@a", [4, 0]]]
# @@aa
[:var_ref, [:@cvar, "@@a", [5, 0]]]
</code></pre>

<p><code>:var_ref</code> (presumably &ldquo;variable reference&rdquo;) is shared by many of these examples, and can always be resolved to a <em>variable</em> lookup, never a method call.
Its argument tells what kind of lookup to do (global, constant, instance, class), and what name to look up.</p>

<h3>Method calls</h3>

<p>Some Ruby can be statically known to be a method call, <em>not</em> a variable lookup:</p>

<pre><code class="ruby"># a(), explicit method call (with parens) on implicit self
[:method_add_arg, [:fcall, [:@ident, "a", [1, 0]]], [:arg_paren, nil]]
# self.a, explicit method call (with dot) on explicit self
[:call, [:var_ref, [:@kw, "self", [1, 0]]], :".", [:@ident, "a", [1, 5]]]
# a b, explicit method call (with arguments) on implicit self
[:command,
   [:@ident, "a", [10, 0]],
   [:args_add_block,
    [:args_add, [:args_new], [:vcall, [:@ident, "b", [10, 2]]]],
    false]]]
</code></pre>

<p>In these cases, <code>:fcall</code>, <code>:call</code> and <code>:command</code> are used to represent definite method sends.</p>

<p>Interestingly, <code>:var_ref</code> is used for <code>self</code>, too.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Updating GitHub to GraphQL 1.8.0]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/04/09/updating-github-to-graphql-1-dot-8-0/"/>
    <updated>2018-04-09T09:52:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/04/09/updating-github-to-graphql-1-dot-8-0</id>
    <content type="html"><![CDATA[<p>GraphQL 1.8.0 was designed and built largely as a part of my work at GitHub. Besides designing the <a href="http://graphql-ruby.org/schema/class_based_api">new Schema definition API</a>, I migrated our codebase to use it. Here are some field notes from my migration.</p>

<!-- more -->


<p>If you want to know more about the motivations behind this work, check out this <a href="/blog/2018/03/25/why-a-new-schema-definition-api/">previous post</a>.</p>

<p>Below, I&rsquo;ll cover:</p>

<ul>
<li>The Process: in general, how I went about migrating our code</li>
<li>The Upgrader: how to run it and roughly how it&rsquo;s organized</li>
<li>Custom Transforms: extensions I made for the upgrader to work on GitHub-specific code</li>
<li>Fixes By Hand: bits of code that needed more work (some of these could be automated, but aren&rsquo;t yet!)</li>
<li>Porting Relay Types: using the class-based API for connections and edges</li>
<li>Migrating DSL extensions: how to support custom GraphQL extension in the new API</li>
</ul>


<h2>The Process</h2>

<p>GitHub&rsquo;s type definitions are separated into folders by type, for example: <code>objects/</code>, <code>unions/</code>, <code>enums/</code> (and <code>mutations/</code>). I worked through them one folder at a time. The <code>objects/</code> folder was big, so I did it twenty or thirty files at a time.</p>

<p>I had to do <code>interfaces/</code> last because of the nature of the new class-based schema. Interfaces modules' methods can&rsquo;t be added to legacy-style GraphQL object types. So, by doing interfaces last, I didn&rsquo;t have to worry about this compatibility issue.</p>

<p>Now that I remember it, I did the schema <em>first</em>, and by hand. It was a pretty easy upgrade.</p>

<p>When I started each section, I created a base class by hand. (There is some automated support for this, but I didn&rsquo;t use it.) Then, I ran the upgrader on some files and tried to run the test suite. There were usually two kinds of errors:</p>

<ul>
<li>Parse- or load-time errors which prevented the app from booting</li>
<li>Runtime errors which resulted in unexpected behavior or raised errors</li>
</ul>


<p>More on these errors below.</p>

<p>After upgrading a section of the schema, I opened a PR for review from the team. This was crucial: since I was working at such a large scale, it was easy for me to miss the trees for the forest. My teammates caught a lot of things during the process!</p>

<p>After a review, the PR would be merged into master. Since GraphQL 1.8.0 supports incremental migration, I could work through the code in chunks without a long running branch or feature flags.</p>

<h2>About the Upgrader</h2>

<p>Here&rsquo;s an overview of how the upgrader works. After reading the overview, if you want some specific examples, check out the <a href="https://github.com/rmosolgo/graphql-ruby/blob/master/lib/graphql/upgrader/member.rb">source code</a>.</p>

<h3>Running The Upgrader</h3>

<p>The gem includes an auto-upgrader, spearheaded by the folks at <a href="https://hackerone.com">HackerOne</a> and refined during my use of it. It&rsquo;s encapsulated in a class, <code>GraphQL::Upgrader::Member</code>.</p>

<p>To use the upgrader, I added a Ruby script to the code base called <code>graphql-update.rb</code>:</p>

<pre><code class="ruby"># Usage:
#   ruby graphql-update.rb path/to/type_definition.rb
#
# Example:
#   # Upgrade `BlameRange`
#   ruby graphql-update.rb lib/platform/objects/blame_range.rb
#
#   # Upgrade based on a pattern (use quotes)
#   ruby graphql-update.rb "lib/platform/objects/blob_\*.rb"
#
#   # Upgrade one more file in this pattern (use quotes)
#   ruby graphql-update.rb 1 "lib/platform/objects/**.rb"

# Load the upgrader from local code, for easier trial-and-error development
# require "~/code/graphql-ruby/lib/graphql/upgrader/member"
# Load the upgrader from the Gem:
require "graphql/upgrader/member"

# Accept two arguments: next_files (optional), file_pattern (required)
file_pattern = ARGV[0]
if file_pattern =~ /\d+/
  next_files = file_pattern.to_i
  next_files_pattern = ARGV[1]
  "Upgrading #{next_files} more files in #{next_files_pattern}"
  filenames = Dir.glob(next_files_pattern)
else
  filenames = Dir.glob(file_pattern)
  next_files = nil
  puts "Upgrading #{filenames.join(", ")}"
end

# ...
# Lots of custom rules here, see below
# ...

CUSTOM_TRANSFORMS = {
  type_transforms: type_transforms,
  field_transforms: field_transforms,
  clean_up_transforms: clean_up_transforms,
  skip: CustomSkip,
}

upgraded = []
filenames.each do |filename|
  puts "Begin (#{filename})"
  # Read the file into a string
  original_text = File.read(filename)
  # Create an Upgrader with the set of custom transforms
  GraphQL::Upgrader::Member.new(original_text, **CUSTOM_TRANSFORMS)
  # Generate updated text
  transformed_text = upgrader.upgrade
  if transformed_text == original_text
    # No upgrade was performed
  else
    # If the upgrade was successful, update the source file
    File.write(filename, transformed_text)
    upgraded &lt;&lt; filename
  end
  puts "Done (#{filename})"
  if next_files &amp;&amp; upgraded.size &gt;= next_files
    # We've upgraded as many as we said we would
    break
  end
end
puts "Upgraded #{upgraded.size} files: \n#{upgraded.join("\n")}"
</code></pre>

<p>This script has two basic parts:</p>

<ul>
<li>Using <code>GraphQL::Upgrader::Member</code> with a set of custom transformations</li>
<li>Supporting code: accepting input, counting files, logging, etc</li>
</ul>


<p>In your own script, you can write whatever supporting code you want. The key part from GraphQL-Ruby is:</p>

<pre><code class="ruby"># Create an Upgrader with the set of custom transforms
GraphQL::Upgrader::Member.new(original_text, **CUSTOM_TRANSFORMS)
# Generate updated text
transformed_text = upgrader.upgrade
</code></pre>

<h3>The Pipeline</h3>

<p>The upgrader is structured as a pipeline: each step accepts a big string of input and returns a big string of output. Sometimes, a step does nothing and so its returned string is the same as the input string. In general, the transforms consist of two steps:</p>

<ul>
<li>Check whether the transform applies to the given input</li>
<li>If it does, copy the string and apply a find-and-replace to it (sometimes using RegExp, other times using the excellent <code>parser</code> gem.)</li>
</ul>


<p>You have a few options for customizing the transformation pipeline:</p>

<ul>
<li>Write new transforms and add them to the pipeline</li>
<li>Remove transforms from the pipeline</li>
<li>Re-use the built-in transforms, but give them different parameters, then replace the built-in one with your custom instance</li>
</ul>


<p>(The &ldquo;pipeline&rdquo; is just an array of instances or subclasses of <code>GraphQL::Upgrader::Transform</code>.)</p>

<p>We&rsquo;ll see cases of each below.</p>

<h3>Kinds of Transforms</h3>

<p>The upgrader accepts several types of transform pipelines:</p>

<pre><code class="ruby">CUSTOM_TRANSFORMS = {
  type_transforms: type_transforms,
  field_transforms: field_transforms,
  clean_up_transforms: clean_up_transforms,
  skip: CustomSkip,
}
</code></pre>

<ul>
<li><code>type_transforms</code> are run first, on the <em>entire</em> file.</li>
<li><code>field_transforms</code> are run second, but they receive <em>parts</em> of the type definition. They receive calls to <code>field</code>, <code>connection</code>, <code>return_field</code>, <code>input_field</code>, and <code>argument</code>. Fine-grained changes to field definition or argument definition go here.</li>
<li><code>clean_up_transforms</code> are run last, on the <em>entire</em> file. For example, there&rsquo;s a built-in <code>RemoveExcessWhitespaceTransform</code> which cleans up trailing spaces after other transforms have run.</li>
<li><code>skip:</code> has a special function: its <code>#skip?(input)</code> method is called and if it returns true, the text is not transformed at all. This allows the transformer to be idempotent: by default, if you run it on the same file over and over, it will update the file only <em>once</em>.</li>
</ul>


<h2>Custom Transforms</h2>

<p>Here are some custom transforms applied to our codebase.</p>

<h3>Handle a custom type-definition DSL</h3>

<p>We had a wrapper around <code>ObjectType.define</code> which attached metadata, linking the object type to a specific Rails model. The helper was called <code>define_active_record_type</code>. I wanted to take this:</p>

<pre><code class="ruby">module Platform
  module Objects
    Issue = define_active_record_type(-&gt; { ::Issue }) do
      # ...
    end
  end
end
</code></pre>

<p>And make it this:</p>

<pre><code class="ruby">module Platform
  module Objects
    class Issue &lt; Platform::Objects::Base
      model_name "Issue"
      # ...
    end
  end
end
</code></pre>

<p>Fortunately, this can be done with a pretty straightforward regular expression substitution. Here&rsquo;s the transform:</p>

<pre><code class="ruby"># Create a custom transform for our `define_active_record_type` factory:
class ActiveRecordTypeToClassTransform &lt; GraphQL::Upgrader::Transform
  # Capture: leading whitespace, type name, model name
  FIND_PATTERN = /^( +)([a-zA-Z_0-9:]*) = define_active_record_type\(-&gt; ?\{ ?:{0,2}([a-zA-Z_0-9:]*) ?\} ?\) do/
  # Restructure as a class, using the leading whitespace and adding the `model_name` DSL
  REPLACE_PATTERN = "\\1class \\2 &lt; Platform::Objects::Base\n\\1  model_name \"\\3\""

  def apply(input_text)
    # It's safe to apply this transform to _all_ input,
    # since it's a no-op if `FIND_PATTERN` is missing.
    input_text.sub(FIND_PATTERN, REPLACE_PATTERN)
  end
end
</code></pre>

<p>Then, in <code>graphql-update.rb</code>, this transform was put <em>first</em> in the list:</p>

<pre><code class="ruby"># graphql-update.rb
type_transforms = GraphQL::Upgrader::Member::DEFAULT_TYPE_TRANSFORMS.dup
type_transforms.unshift(ActiveRecordTypeToClassTransform)
</code></pre>

<p>Also, for this to work, I added the <code>def self.model_name(name)</code> helper to the base class.</p>

<h3>Renaming a Custom Field Method</h3>

<p>We have a helper for adding URL fields called <code>define_url_field</code>. I decided to rename this to <code>url_fields</code>, since these days it creates <em>two</em> fields.</p>

<p>The arguments are the same, so it was a simple substitution:</p>

<pre><code class="ruby">class UrlFieldTransform &lt; GraphQL::Upgrader::Transform
  def apply(input_text)
    # Capture the leading whitespace and the rest of the line,
    # then insert the new name where the old name used to be
    input_text.gsub(/^( +)define_url_field( |\()/, "\\1url_fields\\2")
  end
end
</code></pre>

<p>This transform didn&rsquo;t interact with any other transforms, so I added it to <code>clean_up_transforms</code>, so it would run last:</p>

<pre><code class="ruby"># Make a copy of the built-in arry
clean_up_transforms = GraphQL::Upgrader::Member::DEFAULT_CLEAN_UP_TRANSFORMS.dup
# Add my custom transform to the end of the array
clean_up_transforms.push(UrlFieldTransform)
</code></pre>

<h3>Moving DSL methods to keywords</h3>

<p>We have a few DSL methods that, at the time, were easier to implement as keyword arguments. (Since then, the API has changed a bit. You can implement DSL methods on your fields by extending <code>GraphQL::Schema::Field</code> and setting that class as <code>field_class</code> on your base Object, Interface and Mutation classes.)</p>

<p>I wanted to transform:</p>

<pre><code class="ruby">field :secretStuff, types.String do
  visibility :secret
end
</code></pre>

<p>To:</p>

<pre><code class="ruby">field :secretStuff, types.String, visibility: :secret
</code></pre>

<p>(Later, a built-in upgrader would change <code>secretStuff</code> to <code>secret_stuff</code> and <code>types.String</code> to <code>String, null: true</code>.)</p>

<p>To accomplish this, I reused a built-in transform, <code>ConfigurationToKwargTransform</code>, adding it to <code>field_transforms</code>:</p>

<pre><code class="ruby"># Make a copy of the built-in list of defaults
field_transforms = GraphQL::Upgrader::Member::DEFAULT_FIELD_TRANSFORMS.dup
# Put my custom transform at the beginning of the list
field_transforms.unshift(GraphQL::Upgrader::ConfigurationToKwargTransform.new(kwarg: "visibility"))
</code></pre>

<p>In fact, there were several configuration methods moved this way.</p>

<h3>Custom Skip</h3>

<p>As I was working through the code, some files were tougher than others. So, I decided to skip them. I decided that a magic comment:</p>

<pre><code class="ruby"># @skip-auto-upgrade
</code></pre>

<p>would cause a file to be skipped. To implement this, I made a custom skip class:</p>

<pre><code class="ruby">class CustomSkip &lt; GraphQL::Upgrader::SkipOnNullKeyword
  def skip?(input_text)
    super(input_text) || input_text.include?("@skip-auto-upgrade")
  end
end
</code></pre>

<p>And passed it as <code>skip:</code> to the upgrader. Then, later, I removed the comment and tried again. (Fortunately, my procrastination paid off because the upgrader was improved in the meantime!)</p>

<h2>Fixes by Hand</h2>

<p>As I worked, I improved the upgrader to cover as many cases as I could, but there are still a few cases that I had to upgrade by hand. I&rsquo;ll list them here. If you&rsquo;re really dragged down by them, consider opening an issue on GraphQL-Ruby to talk about fixing them. I&rsquo;m sure they <em>can</em> be fixed, I just didn&rsquo;t get to it!</p>

<p>If you want to fix one of these issues, try to replicate the issue by adding to an example <code>spec/fixtures/upgrader</code> and then getting a failing test. Then, you could update the upgrader code to fix that broken test.</p>

<h3>Accessing Arguments By Method</h3>

<p>Arguments could be accessed by method to avoid typos. However, now, since arguments are a Ruby keyword hash, they don&rsquo;t have methods corresponding to their keys.</p>

<p>Unfortunately, the upgrader doesn&rsquo;t do anything about this, it just leaves them there and you get a <code>NoMethodError</code> on <code>Hash</code>.</p>

<p>This could almost certainly be fixed by improving this find-and-replace in <code>ResolveProcToMethodTransform</code>:</p>

<pre><code class="ruby"># Update Argument access to be underscore and symbols
# Update `args[...]` and `args.key?`
method_body = method_body.gsub(/#{args_arg_name}(?&lt;method_begin&gt;\.key\?\(?|\[)["':](?&lt;arg_name&gt;[a-zA-Z0-9_]+)["']?(?&lt;method_end&gt;\]|\))?/) do
 # ...
end
</code></pre>

<p>It only updates a few methods on <code>args</code>, but I bet a similar find-and-replace could replace <em>other</em> method calls, too.</p>

<h3>Argument Usages Outside of Type Definitions</h3>

<p>Sometimes, we take GraphQL arguments and pass them to helper methods:</p>

<pre><code class="ruby">resolve -&gt;(obj, args, ctx) {
  Some::Helper.call(obj, args)
}
</code></pre>

<p>However when this was transformed to:</p>

<pre><code class="ruby">def do_stuff(**arguments)
  Some::Helper.call(@object, arguments)
end
</code></pre>

<p>It would break, because the new <code>arguments</code> value is a Ruby hash with underscored, symbol keys. So, if <code>Some::Helper</code> was using camelized strings to get values, it would stop working.</p>

<p>The upgrader can&rsquo;t really do anything there, since it&rsquo;s not analyzing the codebase. In my case, these were readily apparent because of failing tests, so I went and fixed them.</p>

<h3>context.add_error</h3>

<p>We have some fields that add to the <code>"errors"</code> key <em>and</em> return values, they used <code>ctx.add_error</code> to do so:</p>

<pre><code class="ruby">resolve -&gt;(obj, args, ctx) {
  begin
    obj.count_things
  rescue BackendIsBrokenError
    ctx.add_error(GraphQL::ExecutionError.new("Not working!"))
    0
  end
}
</code></pre>

<p>When upgraded, it doesn&rsquo;t work quite right:</p>

<pre><code class="ruby">def count_things
  begin
    @object.count_things
  rescue BackendIsBrokenError
    @context.add_error(GraphQL::ExecutionError.new("Not working!"))
    0
  end
end
</code></pre>

<p>(If you don&rsquo;t have to return a value, use <code>raise</code> instead, then you can stop reading this part!)</p>

<p>The problem is that <code>@context</code> is not a <em>field-specific</em> context anymore. Instead, it&rsquo;s the query-level context. (This is downside of the new API: we don&rsquo;t have a great way to pass in the field context anymore.)</p>

<p>To address this kind of issues, <code>field</code> accepts a keyword called <code>extras:</code>, which contains a array of symbols. In the case above, we could use <code>:execution_errors</code>:</p>

<pre><code class="ruby">field :count_things, Integer, null: false, extras: [:execution_errors]
def count_things(execution_errors:)
  @object.count_things
rescue BackendIsBrokenError
  execution_errors.add("Not working!")
  0
end
</code></pre>

<p>So, <code>execution_errors</code> was injected into the field as a keyword. It <em>is</em> field-level, so adding errors there works as before.</p>

<p>Other extras are <code>:irep_node</code>, <code>:parent</code>, <code>:ast_node</code>, and <code>:arguments</code>. It&rsquo;s a bit of a hack, but we need <em>something</em> for this!</p>

<h3>Accessing Connection Arguments</h3>

<p>By default, connection arguments (like <code>first</code>, <code>after</code>, <code>last</code>, <code>before</code>) are <em>not</em> passed to the Ruby methods for implementing fields. This is because they&rsquo;re generally used by the automagical (😖) connection wrappers, not the resolve functions.</p>

<p>But, sometimes you just <em>need</em> those old arguments!</p>

<p>If you use <code>extras: [:arguments]</code>, the legacy-style arguments will be injected as a keyword:</p>

<pre><code class="ruby"># `arguments` is the legacy-style Query::Arguments instance
# `field_arguments` is a Ruby hash with symbol, underscored keys.
def things(arguments:, **field_arguments)
  arguments[:first] # =&gt; 5
  # ...
end
</code></pre>

<h3>Fancy String Descriptions</h3>

<p>The upgrader does fine when the description is a <code>"..."</code> or <code>'...'</code> string. But in other cases, it was a bit wacky.</p>

<p>Strings built up with <code>+</code> or <code>\</code> always broke. I had to go back by hand and join them into one string.</p>

<p>Heredoc strings often <em>worked</em>, but only by chance. For example:</p>

<pre><code class="ruby">field :stuff, types.Int do
  description &lt;&lt;~MD
    Here's the stuff
  MD
end
</code></pre>

<p>Would be transformed to:</p>

<pre><code class="ruby">field :stuff, Integer, description: &lt;&lt;~MD, null: true
    Here's the stuff
  MD
</code></pre>

<p>This is valid Ruby, but a bit tricky. This could definitely be improved: since I started my project, GraphQL 1.8 was extended to support <code>description</code> as a <em>method</em> as well as a keyword. So, the upgrader could be improved to leave descriptions in place if they&rsquo;re fancy strings.</p>

<h3>Removed Comments From the Start of Resolve Proc</h3>

<p>I hacked around with the <code>parser</code> gem to transform <code>resolve</code> procs into instance methods, but there&rsquo;s a bug. A proc like this:</p>

<pre><code class="ruby">resolve -&gt;(obj, args, ctx) {
  # Do stuff
  obj.do_stuff { stuff }
}
</code></pre>

<p>Will be transformed to:</p>

<pre><code class="ruby">def stuff
  @object.do_stuff { stuff }
end
</code></pre>

<p>Did you see how the comment was removed? I think I&rsquo;ve somehow wrongly detected the start of the proc body, so that the comment was left out.</p>

<p>In my case, I re-added those comments by hand. But it could probably be fixed in <code>GraphQL::Upgrader::ResolveProcToMethodTransform</code>.</p>

<h3>Hash Reformating?</h3>

<p>I&rsquo;m not sure why, but sometimes a hash of arguments like:</p>

<pre><code class="ruby">obj.do_stuff(
  a: 1,
  b: 2,
  c: 3,
  d: 4,
)
</code></pre>

<p>would be reorganized to</p>

<pre><code class="ruby">obj.do_stuff(
  a: 1,
  b: 2, c: 3, d: 4,
)
</code></pre>

<p>I have no idea why, and I didn&rsquo;t look into it, I just fixed it by hand.</p>

<h3>Issues with Connection DSL</h3>

<p>We have a DSL for making connections, like:</p>

<pre><code class="ruby">Connections.define(Objects::Issue)
</code></pre>

<p>Sometimes, when this connection was inside a proc, it would be wrongly transformed to:</p>

<pre><code class="ruby">field :issues, Connections.define(Objects::Issue) }, ,null: true
</code></pre>

<p>This was invalid Ruby, so the app wouldn&rsquo;t boot, and I would fix it by hand.</p>

<h2>Porting Relay Types</h2>

<p>Generating connection and edge types with the <code>.connection_type</code>/<code>.define_connection</code> and <code>.edge_type</code>/<code>.define_edge</code> methods will work fine with the new API, but if you want to migrate them to classes, you can do it.</p>

<p>It&rsquo;s on my radar because I want to remove our DSL extensions, and that requires updating our custom connection edge types.</p>

<p>Long story, short, it Just Work™ed with the class-based API. The approach was:</p>

<ul>
<li>Add a base class inheriting from our <code>BaseObject</code></li>
<li>Use the new base class&rsquo;s <code>def self.inherited</code> hook to add connection- and edge-related behaviors</li>
<li>Run the upgrader on edge and connection types, then go back and do some manual find-and-replaces to make them work right</li>
</ul>


<p>So, I will share my base classes in case that helps. Sometime it will be nice to upstream this to GraphQL-Ruby, but I&rsquo;m not sure how to do it now.</p>

<p>Base connection class:</p>

<pre><code class="ruby">module Platform
  module Connections
    class Base &lt; Platform::Objects::Base
      # For some reason, these are needed, they call through to the underlying connection wrapper.
      extend Forwardable
      def_delegators :@object, :cursor_from_node, :parent

      # When this class is extended, add the default connection behaviors.
      # This adds a new `graphql_name` and description, and searches
      # for a corresponding edge type.
      # See `.edge_type` for how the fields are added.
      def self.inherited(child_class)
        # We have a convention that connection classes _don't_ end in `Connection`, which
        # is a bit confusing and results in naming conflicts.
        # To avoid a GraphQL conflict, override `graphql_name` to end in `Connection`.
        type_name = child_class.name.split("::").last
        child_class.graphql_name("#{type_name}Connection")

        # Use `require_dependency` so that the types will be loaded, if they exist.
        # Otherwise, `const_get` may reach a top-level constant (eg, `::Issue` model instead of `Platform::Objects::Issue`).
        # That behavior is removed in Ruby 2.5, then we can remove these require_dependency calls too.
        begin
          # Look for a custom edge whose name matches this connection's name
          require_dependency "lib/platform/edges/#{type_name.underscore}"
          wrapped_edge_class = Platform::Edges.const_get(type_name)
          wrapped_node_class = wrapped_edge_class.fields["node"].type
        rescue LoadError =&gt; err
          # If the custom edge file doesn't exist, look for an object
          begin
            require_dependency "lib/platform/objects/#{type_name.underscore}"
            wrapped_node_class = Platform::Objects.const_get(type_name)
            wrapped_edge_class = wrapped_node_class.edge_type
          rescue LoadError =&gt; err
            # Assume that `edge_type` will be called later
          end
        end

        # If a default could be found using constant lookups, generate the fields for it.
        if wrapped_edge_class
          if wrapped_edge_class.is_a?(GraphQL::ObjectType) || (wrapped_edge_class.is_a?(Class) &amp;&amp; wrapped_edge_class &lt; Platform::Edges::Base)
            child_class.edge_type(wrapped_edge_class, node_type: wrapped_node_class)
          else
            raise TypeError, "Missed edge type lookup, didn't find a type definition: #{type_name.inspect} =&gt; #{wrapped_edge_class.inspect}"
          end
        end
      end

      # Configure this connection to return `edges` and `nodes` based on `edge_type_class`.
      #
      # This method will use the inputs to create:
      # - `edges` field
      # - `nodes` field
      # - description
      #
      # It's called when you subclass this base connection, trying to use the
      # class name to set defaults. You can call it again in the class definition
      # to override the default (or provide a value, if the default lookup failed).
      def self.edge_type(edge_type_class, edge_class: GraphQL::Relay::Edge, node_type: nil)
        # Add the edges field, can be overridden later
        field :edges, [edge_type_class, null: true],
          null: true,
          description: "A list of edges.",
          method: :edge_nodes,
          edge_class: edge_class

        # Try to figure out what the node type is, if it wasn't provided:
        if node_type.nil?
          if edge_type_class.is_a?(Class)
            node_type = edge_type_class.fields["node"].type
          elsif edge_type_class.is_a?(GraphQL::ObjectType)
            # This was created with `.edge_type`
            node_type = Platform::Objects.const_get(edge_type_class.name.sub("Edge", ""))
          else
            raise ArgumentError, "Can't get node type from edge type: #{edge_type_class}"
          end
        end

        # If it's a non-null type, remove the wrapper
        if node_type.respond_to?(:of_type)
          node_type = node_type.of_type
        end

        # Make the `nodes` shortcut field, which can be overridden later
        field :nodes, [node_type, null: true],
          null: true,
          description: "A list of nodes."

        # Make a nice description
        description("The connection type for #{node_type.graphql_name}.")
      end

      field :page_info, GraphQL::Relay::PageInfo, null: false, description: "Information to aid in pagination."

      # By default this calls through to the ConnectionWrapper's edge nodes method,
      # but sometimes you need to override it to support the `nodes` field
      def nodes
        @object.edge_nodes
      end
    end
  end
end
</code></pre>

<p>Base edge class:</p>

<pre><code class="ruby">module Platform
  module Edges
    class Base &lt; Platform::Objects::Base
      # A description which is inherited and may be overridden
      description "An edge in a connection."

      def self.inherited(child_class)
        # We have a convention that edge classes _don't_ end in `Edge`,
        # which is a little bit confusing, and would result in a naming conflict by default.
        # Avoid the naming conflict by overriding `graphql_name` to include `Edge`
        wrapped_type_name = child_class.name.split("::").last
        child_class.graphql_name("#{wrapped_type_name}Edge")
        # Add a default `node` field, assuming the object type name matches.
        # If it doesn't match, you can override this in subclasses
        child_class.field :node, "Platform::Objects::#{wrapped_type_name}", null: true, description: "The item at the end of the edge."
      end

      # A cursor field which is inherited
      field :cursor, String,
        null: false,
        description: "A cursor for use in pagination."
    end
  end
end
</code></pre>

<h2>Migrating DSL Extensions</h2>

<p>We have several extensions to the GraphQL-Ruby <code>.define</code> DSL, for example, <code>visibility</code> controls who can see certain types and fields and <code>scopes</code> maps OAuth scopes to GraphQL types.</p>

<p>The difficulty in porting extensions comes from the implementation details of the new API. For now, definition classes are factories for legacy-style type instances. Each class has a <code>.to_graphql</code> method which is called <em>once</em> to return a legacy-style definition. To maintain compatibility, you have to either:</p>

<ul>
<li>Modify the derived legacy-style definition to reflect configurations on the class-based definition; OR</li>
<li>Update your runtime code to <em>stop</em> checking for configurations on the legacy-style definition and <em>start</em> checking for configurations on the class-based definition.</li>
</ul>


<p>Eventually, legacy-style definitions will be phased out of GraphQL-Ruby, but for now, they both exist in this way in order to maintain backwards compatibility and gradual adoptability.</p>

<p>In the mean time, you can go between class-based and legacy-style definitions using <code>.graphql_defintion</code> and <code>.metadata[:type_class]</code>, for example:</p>

<pre><code class="ruby">class Project &lt; BaseObject
  # ...
end

legacy_type = Project.graphql_definition
# #&lt;GraphQL::ObjectType&gt; instance
legacy_type.metadata[:type_class]
# `Project` class
</code></pre>

<h3>The Easy Way: <code>.redefine</code></h3>

<p>The easiest way to retain compatibility is to:</p>

<ul>
<li>Add a class method to your base classes which accept some configuration and put it in instance variables</li>
<li>Override <code>.to_graphql</code> to call super, and then pass the configuration to <code>defn.redefine(...)</code>, then return the redefined type.</li>
</ul>


<p>After my work on our code, I extracted this into a <a href="http://graphql-ruby.org/type_definitions/extensions.html#customization-compatibility">backport of <code>accepts_definition</code></a></p>

<p>You can take that approach for a try, for example:</p>

<pre><code class="ruby">class BaseObject &lt; GraphQL::Schema::Object
  # Add a configuration method
  def self.visibility(level)
    @visibility = level
  end

  # Re-apply the configuration
  def self.to_graphql
    type_defn = super
    # Call through to the old extension:
    type_defn = type_defn.redefine(visibilty: @visibility)
    # Return the redefined type:
    type_defn
  end
end

# Then, use it in type definitions:
class Post &lt; BaseObject
  visibility(:secret)
end
</code></pre>

<h3>The Hard Way: <code>.metadata[:type_class]</code></h3>

<p>An approach I haven&rsquo;t tried yet, but I will soon, is to move the &ldquo;source of truth&rdquo; to the the class-based definition. The challenge here is that class-based definitions are not really used during validation and execution, so how can you reach configuration values on those classes?</p>

<p>The answer is that if a legacy-style type was derived from a class, that class is stored as <code>metadata[:type_class]</code>. For example:</p>

<pre><code class="ruby">class Project &lt; BaseObject
  # ...
end
legacy_defn = Project.graphql_definition # Instance of GraphQL::ObjectType, just like `.define`
legacy_defn.metadata[:type_class] # `Project` class from above
</code></pre>

<p>So, you could update runtime code to read configurations from <code>type_defn.metadata[:type_class]</code>.</p>

<p>Importantly, <code>metadata[:type_class]</code> will be <code>nil</code> if the type <em>wasn&rsquo;t</em> derived from a class, so this approach is tough to use if some definitions are still using the <code>.define</code> API.</p>

<p>I haven&rsquo;t implemented this yet, but I will be doing it in the next few weeks so we can simplify our extensions and improve boot time.</p>

<h2>The End</h2>

<p>I&rsquo;m still wrapping up some loose ends in the codebase, but I thought I&rsquo;d share these notes in case they help you in your upgrade. If you run into trouble on anything mentioned here, please <a href="https://github.com/rmosolgo/graphql-ruby/issues/new">open an issue</a> on GraphQL-Ruby! I really want to support a smooth transition to this new API.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why a New Schema Definition API?]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/03/25/why-a-new-schema-definition-api/"/>
    <updated>2018-03-25T13:59:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/03/25/why-a-new-schema-definition-api</id>
    <content type="html"><![CDATA[<p>GraphQL-Ruby <code>1.8.0</code> will have a new class-based API for defining your schema. Let&rsquo;s investigate the design choices in the new API.</p>

<!-- more -->


<p>The new API is backwards-compatible and can coexist with type definitions in the old format. See <a href="https://github.com/rmosolgo/graphql-ruby/blob/1.8-dev/guides/schema/class_based_api.md#compatibility--migration-overview">the docs</a> for details. <code>1.8.0.pre</code> versions are available on RubyGems now and are very stable &ndash; that&rsquo;s what we&rsquo;re running at GitHub!</p>

<h2>Problems Worth Fixing</h2>

<p>Since starting at GitHub last May, I&rsquo;ve entered into the experience of a huge-scale GraphQL system. Huge scale in lots of ways: huge schema, huge volume, and huge developer base. One of the problems that stood out to me (and to lots of us) was that GraphQL-Ruby simply <em>didn&rsquo;t help</em> us be productive. Elements of schema definition hindered us rather than helped us.</p>

<p>So, our team set out on remaking the GraphQL-Ruby schema definition API. We wanted to address a few specific issues:</p>

<ul>
<li><strong>Familiarity</strong>. GraphQL-Ruby&rsquo;s schema definition API reflected GraphQL and JavaScript more than it reflected Ruby. (The JavaScript influence comes from <code>graphql-js</code>, the reference implementation.) Ruby developers couldn&rsquo;t bring their usual practices into schema development; instead, they had to learn a bunch of new APIs and figure out how to work them together.</li>
<li><strong>Rails Compatibility</strong>, especially constant loading. A good API would work seamlessly with Rails development configurations, but the current API has some gotchas regarding circular dependencies and reloading.</li>
<li><strong>Hackability</strong>. Library code is fine <em>until it isn&rsquo;t</em>, and one of the best (and worst) things about Ruby is that all code is open to extension (or monkey-patching 🙈). At best, this means that library users can customize the library code in straightforward ways to better suit their use cases. However, GraphQL-Ruby didn&rsquo;t support this well: to support special use cases, customizations had to be hacked in in odd ways that were hard to maintain and prone to breaking during gem updates.</li>
</ul>


<p>Besides all that, we needed a <em>safe</em> transition, so it had to support a gradual adoption.</p>

<p>After trying a few different possibilities, the team decided to take a class-based approach to defining GraphQL schemas. I&rsquo;m really thankful for their support in the design process, and I&rsquo;m indebted to the folks at Shopify, who used a class-based schema definition system from the start (as a layer on top of GraphQL-Ruby) and <a href="https://www.youtube.com/watch?v=Wlu_PWCjc6Y">presented their work</a> early on.</p>

<h2>The new API, from 10,000 feet</h2>

<p>In short, GraphQL types used to be singleton instances, built with a <a href="https://twitter.com/krainboltgreene/status/971797438070599680">block-based API</a>:</p>

<pre><code class="ruby">Types::Post = GraphQL::ObjectType.define {
  # ...
}
</code></pre>

<p>Now, GraphQL types are classes, with a DSL implemented as class methods:</p>

<pre><code class="ruby">class Types::Post
  # ...
end
</code></pre>

<p>Field resolution was previously defined using Proc literals:</p>

<pre><code class="ruby">field :comments, types[Types::Comments] do
  argument :orderBy, Types::CommentOrder
  resolve -&gt;(obj, args, ctx) {
    obj.comments.order(args[:orderBy])
  }
end
</code></pre>

<p>Now, field resolution is defined with an instance method:</p>

<pre><code class="ruby">field :comments, [Types::Comments], null: true do
  argument :order_by, Types::CommentOrder, required: false
end

def comments(order_by: nil)
  object.comments.order(order_by)
end
</code></pre>

<p>How does this address the issues listed above?</p>

<h2>More Familiarity</h2>

<p>First, using classes reduces the &ldquo;WTF&rdquo; factor of GraphQL definition code. A seasoned Ruby developer might (rightly) smell foul play and reject GraphQL-Ruby on principle. (I was not seasoned enough to detect this when I designed the API!)</p>

<p>Proc literals are rare in Ruby, but common in GraphQL-Ruby&rsquo;s <code>.define { ... }</code> API. Their lexical scoping rules are different than method scoping rules, making it hard to remember what <em>was</em> and <em>wasn&rsquo;t</em> in scope during field resolution (for example, what was <code>self</code>?). To make matters worse, <em>some</em> of the blocks in the <code>.define</code> API were <code>instance_eval</code>&rsquo;d, so their <code>self</code> would be overridden. Practically, this meant that typos in development resulted in strange <code>NoMethodError</code>s.</p>

<p>Proc literals also have performance downsides: they&rsquo;re not optimized by CRuby, so they&rsquo;re <a href="https://gist.github.com/rmosolgo/6c6a7d787e0f1666f4c6d858c8402a01#gistcomment-1843329">slower than method calls</a>. Since they capture a lexical scope, they may also have <a href="https://github.com/github/graphql-client/pull/139">unexpected impacts on memory footprint</a> (any local variable may be retained, since it might be accessed by the proc). The solutions here are simple: just use methods, the way Ruby wants you to! 😬</p>

<p>In the new class-based API, there are no proc literals (although they&rsquo;re supported for compatibility&rsquo;s sake). There are some <code>instance_eval</code>&rsquo;d blocks (<code>field(...) { }</code>, for example), but field resolution is <em>just an instance method</em> and the type definition is a normal class, so module scoping works normally. (Contrast that with the constant assignment in <code>Types::Post = GraphQL::ObjectType.define { ... }</code>, where no module scope is used). Several hooks that were previously specified as procs are now class methods, such as <code>resolve_type</code> and <code>coerce_input</code> (for scalars).</p>

<p>Overriding <code>!</code> is another particular no-no I&rsquo;m correcting. At the time, I thought, &ldquo;what a cool way to bring a GraphQL concept into Ruby!&rdquo; This is because GraphQL non-null types are expressed with <code>!</code>:</p>

<pre><code class="ruby"># This field always returns a User, never `null`
author: User!
</code></pre>

<p>So, why not express the concept with Ruby&rsquo;s <code>!</code> method (which is usually used for negation)?</p>

<pre><code class="ruby">field :author, !User
</code></pre>

<p>As it turns out, there are several good reasons for <em>why not</em>!</p>

<ul>
<li>Overriding <code>!</code> breaks the negation operator. ActiveSupport&rsquo;s <code>.present?</code> didn&rsquo;t work with type objects, because <code>!</code> didn&rsquo;t return <code>false</code>, it returned a non-null type.</li>
<li>Overriding the <code>!</code> operator throws people off. When a newcomer sees GraphQL-Ruby sample code, they have a WTF moment, followed by the dreadful memory (or discovery) that Ruby allows you to override <code>!</code>.</li>
<li>There&rsquo;s very little value in importing GraphQL concepts into Ruby. GraphQL-Ruby developers are generally seasoned Ruby developers who are just learning GraphQL, so they don&rsquo;t gain anything by the similarity to GraphQL.</li>
</ul>


<p>So, overriding <code>!</code> didn&rsquo;t deliver any value, but it did present a roadblock to developers and break some really essential code.</p>

<p>In the new API, nullability is expressed with the options <code>null:</code> and <code>required:</code> instead of with <code>!</code>. (But, you can re-activate that override for compatibility while you transition to the new API.)</p>

<p>By switching to Ruby&rsquo;s happy path of classes and methods, we can help Ruby developers feel more at home in GraphQL definitions. Additionally, we avoid some unfamiliar gotchas of procs and clear a path for removing the <code>!</code> override.</p>

<h2>Rails Compatibility</h2>

<p>Rails' automatic constant loading is wonderful &hellip; until it&rsquo;s <em>not</em>! GraphQL-Ruby didn&rsquo;t play well with Rails' constant loading especially when it came to cyclical dependencies, and here&rsquo;s why.</p>

<p>Imagine a typical <code>.define</code>-style type definition, like this:</p>

<pre><code class="ruby">Types::T = GraphQL::ObjectType.define { ... }
</code></pre>

<p>We&rsquo;re assigning the constant <code>Types::T</code> to the return value of <code>.define { ... }</code>. Consequently, the constant is not defined <em>until</em> <code>.define</code> returns.</p>

<p>Let&rsquo;s expand the example to two type definitions:</p>

<pre><code class="ruby">Types::T1 = GraphQL::ObjectType.define { ... }
Types::T2 = GraphQL::ObjectType.define { ... }
</code></pre>

<p>If <code>T1</code> depends on <code>T2</code>, <em>and</em> <code>T2</code> depends on <code>T1</code>, how can this work? (For example, imagine a <code>Post</code> type whose <code>author</code> field returns a <code>User</code>, and a <code>User</code> type whose <code>posts</code> field returns a list of <code>Post</code>s. This kind of cyclical dependency is common!) GraphQL-Ruby&rsquo;s solution was to adopt a JavaScriptism, a <em>thunk</em>. (Technically, I guess it&rsquo;s a functional programming-ism, but I got it from <code>graphql-js</code>.) A <em>thunk</em> is an anonymous function used to defer the resolution of a value. For example, if we have code like this:</p>

<pre><code class="ruby">field :author, Types::User
# NameError: uninitialized constant Types::User
</code></pre>

<p>GraphQL-Ruby would accept this:</p>

<pre><code class="ruby">field :author, -&gt; { Types::User }
# Thanks for the function, I will call it later to get the value!
</code></pre>

<p>Later, GraphQL-Ruby would <code>.call</code> the proc and get the value. At that type, <code>Types::User</code> would properly resolve to the correct type. This <em>worked</em> but it had two big downsides:</p>

<ul>
<li>It added an unfamiliar construct (<code>Proc</code>) in an unfamiliar context (a method argument), so it was frustrating and disorienting.</li>
<li>It added visual noise to the source code.</li>
</ul>


<p>How does switching to classes resolve this issue? To ask the same question, how come we don&rsquo;t experience this problem with normal Rails models?</p>

<p>Part of the answer has to do with <em>how classes are evaluated</em>. Consider two classes in two different files:</p>

<pre><code class="ruby"># app/graphql/types/post.rb
module Types
  class Post &lt; BaseObject
    field :author, Types::User, null: false
  end
end
# app/graphql/types/user.rb
module Types
  class User &lt; BaseObject
    field :posts, [Types::Post], null: false
  end
end
</code></pre>

<p>Notice that <code>Post</code> depends on <code>User</code>, and <code>User</code> depends on <code>Post</code>. The difference is how these lines are evaluated, and when the constants become defined. Here&rsquo;s the same code, with numbering to indicate the order that lines are evaluated:</p>

<pre><code class="ruby"># Let's assume that `Post` is loaded first.
# app/graphql/types/post.rb
module Types                                  # 1, evaluation starts here
  class Post &lt; BaseObject                     # 2, and naturally flows here, constant `Types::Post` is initialized as a class extending BaseObject
    field :author, Types::User, null: false   # 3, but when evaluating `Types::User`, jumps down below
  end                                         # 9, execution resumes here after loading `Types::User`
end                                           # 10
# app/graphql/types/user.rb
module Types                                  # 4, Rails opens this file looking for `Types::User`
  class User &lt; BaseObject                     # 5, constant `Types::User` is initialized
    field :posts, [Types::Post], null: false  # 6, this line finishes without jumping, because `Types::Post` is _already_ initialized (see `# 2` above)
  end                                         # 7
end                                           # 8
</code></pre>

<p>Since <code>Types::Post</code> is <em>initialized</em> first, then built-up by the following lines of code, it&rsquo;s available to <code>Types::User</code> in the case of a circular dependency. As a result, the thunk is not necessary.</p>

<p>This approach isn&rsquo;t a silver bullet &ndash; <code>Types::Post</code> is not fully initialized by the time <code>Types::User</code> needs it &ndash; but it reduces visual friction and generally plays nice with Rails out of the box.</p>

<h2>Hackability</h2>

<p>I&rsquo;ve used a naughty word here, but in fact, I&rsquo;m talking about something very good. Have you ever been stuck with some dependency that didn&rsquo;t quite fit your application? (Or, maybe you were stuck on an old version, or your app needed a new feature that wasn&rsquo;t quite supported by the library.) Like it or not, sometimes the only way forward in a case like that is to hack it: reopen classes, redefine methods, mess with the inheritance chain, etc. Yes, those choices come with maintenance downsides, but sometimes they&rsquo;re really the best way forward.</p>

<p>On the other hand, really flexible libraries are <em>ready</em> for you to come and extend them. For example, they might provide base classes for you to extend, with the assumption that you&rsquo;ll override and implement certain methods. In that case, the same hacking techniques listed above have found their time to shine.</p>

<p><code>ActiveRecord::Base</code> is a great example of both cases: plenty of libraries hack methods right into the built-in class (for example, <code>acts_as_{whatever}</code>), and also, lots of Rails apps use an <code>ApplicationRecord</code> class for their application-specific customizations.</p>

<p>Since GraphQL-Ruby didn&rsquo;t use the familiar arrangement of classes and methods, it was closed to this kind of extension. (Ok, you <em>could</em> do it, but it was a lot of work! And who wants to do that!?) In place of this, GraphQL-Ruby had yet-another-API for extending its DSL. Yet another thing to learn, with more Proc literals 😪.</p>

<p>Using classes simplifies this process because you can use familiar Ruby techniques to build your GraphQL schema. For example, if you want to share code between field resolvers, you can <code>include</code> a module and call its methods. If you want to make shorthands for common cases in your app, you can use your <code>Base</code> type classes. If you want to add special configuration to your types, you can use class methods. And, whenever that day should come, when you need to monkey-patch GraphQL-Ruby internals, I hope you&rsquo;ll be able to find the right spot to do it!</p>

<h2>Stay Classy</h2>

<p>GraphQL-Ruby is three years old now, and I&rsquo;ve learned a LOT during that time! I&rsquo;m really thankful for the opportunity to focus on <em>developer productivity</em> in the last few months, learning how I&rsquo;ve prevented it and working on ways to improve it. I hope to keep working on topics like this &ndash; how to make GraphQL more productive for Ruby developers &ndash; in the next year, especially, so if you have feedback on this new API, please <a href="https://github.com/rmosolgo/graphql-ruby/issues/new">open an issue</a> to share it!</p>

<p>I&rsquo;m excited to see how this new API changes the way people think about GraphQL in Ruby, and I hope it will foster more creativity and stability.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Type Checking Roundup]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/10/06/ruby-type-checking-roundup/"/>
    <updated>2017-10-06T09:00:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/10/06/ruby-type-checking-roundup</id>
    <content type="html"><![CDATA[<p>This fall, several people presented their work on Ruby type checkers. So let&rsquo;s take a look: what&rsquo;s the big deal, and what have they been up to?</p>

<!-- more -->


<h2>Why Type Check?</h2>

<p>Part of Ruby&rsquo;s appeal is to be <em>free</em> of the cruft of its predecessors. So why is there so much interest in <em>adding</em> types to Ruby?</p>

<ul>
<li>Large, sprawling projects are becoming more common. At Ruby&rsquo;s inception, there were no 10-year-old Rails apps which people struggled to maintain, only greenfield Ruby scripts for toy projects.</li>
<li>Programmers have experienced excellent type systems in other languages, and want those benefits in Ruby.</li>
<li><em>Optional</em>, gradual type systems have been introduced to Python and JavaScript and they&rsquo;re big successes.</li>
</ul>


<p>What are the benefits?</p>

<ul>
<li><strong>Correctness</strong>: Type checking, like testing, is a way to be confident that your codebase is functioning properly. Employing a type checker can help you find bugs during development and prevent those bugs from going to production.</li>
<li><strong>Confidence</strong>: Since an incorrect program won&rsquo;t pass type checking, developers can refactor with more confidence. Common errors such as typos and argument errors can be caught by the type checker.</li>
<li><strong>Design</strong>: The type system gives you a way to think about the program. Specifically, types document and define the <em>boundaries</em> between parts of code, like methods, classes and modules.</li>
</ul>


<p>To experience a great type system in a Ruby-like language, I recommend <a href="https://crystal-lang.org/">Crystal</a>.</p>

<h2>Jeff Foster, StrangeLoop 2017</h2>

<p><a href="http://www.cs.umd.edu/~jfoster/">Jeff Foster</a> is a professor at the <a href="http://www.umd.edu/">University of Maryland, College Park</a> and works in the <a href="http://www.cs.umd.edu/projects/PL/">programming languages group</a>. Along with his students, he&rsquo;s been exploring Ruby type checkers for <strong>nine years</strong>! This year, he gave a presentation at StrangeLoop, <a href="https://www.youtube.com/watch?v=buY54I7mEjA">Type Checking Ruby</a>.</p>

<p>He described his various avenues of research over the years, and how they influenced one another, leading to a final question:</p>

<pre><code class="ruby">class Talk &lt; ActiveRecord::Base
  belongs_to :owner, class_name: "User"

  def owner?(other_user)
    # QUESTION
    # How to know the type of `#owner` method at this point?
    owner == other_user
  end
end
</code></pre>

<p>His early work revolved around <em>static</em> type checking: annotations in the source code were given to a type checker, which used those annotations to assert that the Ruby code was correct.</p>

<p>This approach had a fundamental limitation: how can dynamically-created methods (like <code>Talk#owner</code> above) be statically annotated?</p>

<p>This drove him and his team to develop <a href="https://github.com/plum-umd/rdl">RDL</a>, a <em>dynamic</em> type checker. In RDL, types are declared using <em>methods</em> instead of annotations, for example:</p>

<pre><code class="ruby">type '(Integer, Integer) -&gt; Integer'
def multiply(x, y)
  x * y
end
</code></pre>

<p>By using methods, it handles metaprogramming in a straightforward way. It hooks into Rails' <code>.belongs_to</code> and adds annotations for the generated methods, for example:</p>

<pre><code class="ruby"># Rails' belongs_to method
def belongs_to(name, options = {})
  # ...
  # define a reader method, like `Talk#owner` above
  type "() -&gt; #{class_name}"
  define_method(name) do
    # ...
  end
end
</code></pre>

<p>(In reality, RDL uses <a href="https://github.com/plum-umd/rdl#preconditions-and-postconditions">conditions</a>, not monkey-patching, to achieve this.)</p>

<p>In this approach, type information is <em>gathered while the program runs</em>, but the typecheck is deferred until the method is called. At that point, RDL checks the source code (static information) using the runtime data (dynamic information). For this reason, RDL is called &ldquo;Just-in-Time Static Type Checking.&rdquo;</p>

<p>You can learn more about RDL in several places:</p>

<ul>
<li>RDL on GitHub: <a href="https://github.com/plum-umd/rdl">https://github.com/plum-umd/rdl</a></li>
<li>StrangeLoop 2017 talk: <a href="https://www.youtube.com/watch?v=buY54I7mEjA">https://www.youtube.com/watch?v=buY54I7mEjA</a></li>
<li>Academic papers from the folks behind RDL: <a href="https://github.com/plum-umd/rdl#bibliography">https://github.com/plum-umd/rdl#bibliography</a></li>
</ul>


<p>Personally, I can&rsquo;t wait to take RDL for a try. At the conference, Jeff mentioned that <em>type inference</em> was on his radar. That would take RDL to the next level!</p>

<p>Not to read into it too far, but it looks like <a href="https://github.com/plum-umd/rdl/issues/40#issuecomment-329135921">Stripe is exploring RDL</a> 😎.</p>

<h2>Soutaro Matsumoto, RubyKaigi 2017</h2>

<p>Soutaro Matsumoto also has significant academic experience with type checking Ruby, and this year, he presented some of his work at RubyKaigi in <a href="https://youtu.be/JExXdUux024">Type Checking Ruby Programs with Annotations</a>.</p>

<p>He begins with an overview of type checking Ruby, and surveys the previous work in type inference. He also points out how requirements should be relaxed for Ruby:</p>

<ul>
<li><strong><del>Correctness</del> -> Forget correctness</strong> (Allow a mix of typed and untyped code, so that developers can work quickly when they don&rsquo;t want or need types.)</li>
<li><strong><del>Static</del> -> Defer type checking to runtime</strong> (He mentions RDL in this context)</li>
<li><strong><del>No annotations</del> -> Let programmers write types</strong> (<em>Completely</em> inferring types is not possible, so accept some hints from the developers.)</li>
</ul>


<p>Then, he introduces his recent project, <a href="https://github.com/soutaro/steep">Steep</a>.</p>

<p>Steep&rsquo;s approach is familiar, but new to Ruby. It has three steps:</p>

<ul>
<li>Write a <code>.rbi</code> file which describes the types in your program, using a special type language, for example:</li>
</ul>


<pre><code class="ruby">class Talk {
  def owner: (User) -&gt; _Boolean
}
</code></pre>

<ul>
<li>Add annotations to your Ruby code to connect it to your types:</li>
</ul>


<pre><code class="ruby">class Talk &lt; ActiveRecord::Base
  belongs_to :owner, class_name: "User"
  # @dynamic owner
end
</code></pre>

<p>  Some connections between Ruby source and the <code>.rbi</code> files can be made automatically; others require explicit annotations.</p>

<ul>
<li><p>Run the type checker:</p>

<pre><code>$ steep check app/models/talk.rb
</code></pre></li>
</ul>


<p>It reminds me a bit of the <code>.h</code>/<code>.c</code> files in a C project.</p>

<p>Soutaro is also presenting his work at <a href="http://rubyconf.org/program#session-233">this winter&rsquo;s RubyConf</a>.</p>

<h2>Valentin Fondaratov, RubyKaigi 2017</h2>

<p>Valentin works at JetBrains (creators of <a href="https://www.jetbrains.com/ruby/">RubyMine</a>) and presented his work on type-checking based on <em>runtime</em> data. His presentation, <a href="https://www.youtube.com/watch?v=JS6m2gke0Ic">Automated Type Contracts Generation for Ruby</a>, was really fascinating and offered a promising glimpse of what a Ruby type ecosystem could be.</p>

<p>Valentin started by covering RubyMine&rsquo;s current type checking system:</p>

<ul>
<li>RubyMine tries to resolve identifiers (eg, method names, constant names) to their implementations</li>
<li>But this is hard: given <code>obj.execute</code>, what method does it call?</li>
<li>Developers can provide hints with YARD documentation</li>
<li>RubyMine uses this to support autocomplete, error prediction, and rename refactorings</li>
</ul>


<p>He also pointed out that even code coverage is not enough: 100% code coverage does <em>not</em> guarantee that all <em>possible</em> codepaths were run. For example, any composition of <code>if</code> branches require a cross-product of codepaths, not only that each line is executed once. Besides that, code coverage does <em>not</em> analyze the coverage of your dependencies' code (ie, RubyGems).</p>

<p>So, Valentin suggests getting <em>more</em> from our unit tests: what if we <em>observed</em> the running program, and kept notes about what values were passed around and how they were used? In this arrangement, that <em>runtime</em> data could be accumulated, then used for type checking.</p>

<p>Impressively, he introduced the implementation of this, first using a <a href="ruby-doc.org/core-2.4.0/TracePoint.html">TracePoint</a>, then digging into the Ruby VM to get even more granular data.</p>

<p>However, the gathered data can be very complicated. For example, how can we understand the input type of <code>String#split</code>?</p>

<pre><code class="ruby"># A lot of type checking data generated at runtime:
# call                                # Input type
"1,2,,3,4,,".split(",")               # (String, nil)
# =&gt; ["1", "2", "", "3", "4"]
"1,2,,3,4,,".split(",", 4)            # (String, Integer)
# =&gt; ["1", "2", "", "3,4,,"]
"1,2,,3,4,,".split(",", -4)           # (String, Integer)
# =&gt; ["1", "2", "", "3", "4", "", ""]
"1,2,,3,4,,".split(/\d/)              # (Regexp, nil)
# =&gt; ["", ",", ",,", ",", ",,"]
# ...
</code></pre>

<p>Valentin showed how a classic technique, finite automata, can be used to reduce this information to a useful data structure.</p>

<p>Then, this runtime data can be used to <em>generate</em> type annotations (as YARD docs).</p>

<p>Finally, he imagines a type ecosystem for Ruby:</p>

<ul>
<li>Users contribute their (anonymized) runtime information for their RubyGem depenedencies</li>
<li>This data is pooled into a shared database, merged by RubyGem &amp; version</li>
<li>Users can draw type data <em>from</em> the shared database</li>
</ul>


<p>Personally, I think this is a great future to pursue:</p>

<ul>
<li>Developers can <em>gain</em> type checking without any annotations</li>
<li>Annotations can become very robust because resources are shared</li>
<li><em>Real</em> 100% coverage is possible via community collaboration</li>
</ul>


<p>You can see the project on GitHub: <a href="https://github.com/JetBrains/ruby-type-inference">https://github.com/JetBrains/ruby-type-inference</a></p>

<h2>Summary</h2>

<p>There&rsquo;s a lot of technically-savvy and academically-informed work on type checking Ruby! Many of the techniques preserve Ruby&rsquo;s productivity and dynamism while improving the developer experience and confidence. What makes them unique is their use of <em>runtime</em> data, to observe the program in action, then make assertions about the source code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What's new in React-Rails 2.0?]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/04/13/whats-new-in-react-rails-2-dot-0/"/>
    <updated>2017-04-13T11:59:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/04/13/whats-new-in-react-rails-2-dot-0</id>
    <content type="html"><![CDATA[<p>For <a href="http://planning.center">Planning Center</a> free week, I cooked up <a href="https://github.com/reactjs/react-rails"><code>react-rails</code></a> 2.0 🎊.</p>

<!-- more -->


<p>Here are a few highlights. For the full list, see the <a href="https://github.com/reactjs/react-rails/blob/master/CHANGELOG.md">changelog</a>!</p>

<h2>Webpacker support</h2>

<p><a href="https://github.com/rails/webpacker">Webpacker</a> was great to work with. <code>react-rails</code> now supports webpacker for:</p>

<ul>
<li>Mounting components with <code>&lt;%= react_component(...) %&gt;</code> via <code>require</code></li>
<li>Server rendering from a webpacker pack (<code>server_rendering.js</code>)</li>
<li>Loading the unobtrusive JavaScript (UJS)</li>
<li>Installation and component generators</li>
</ul>


<p>A nice advantage of using webpacker is that you can load React.js from NPM instead of the <code>react-rails</code> gem. This way, you aren&rsquo;t bound to the React.js version which is included with the Ruby gem. You can pick any version you want!</p>

<h2>UJS on npm</h2>

<p>To support frontends built with Node.js, <code>react-rails</code>&rsquo;s  UJS driver is available on NPM as <a href="https://www.npmjs.com/package/react_ujs"><code>react_ujs</code></a>. It performs setup during <code>require</code>, so these two are equal:</p>

<pre><code class="js">// Sprockets:
//= require react_ujs

// Node, etc:
require("react_ujs")
</code></pre>

<h2>Request-based prerender context</h2>

<p>If you&rsquo;re prerendering your React components on the server, you can perform setup and teardown in your Rails controller. For example, you might use these hooks to populate a flux store.</p>

<p>First, add the <code>per_request_react_rails_prerenderer</code> helper to your controller:</p>

<pre><code class="ruby">class PagesController &lt; ApplicationController
  per_request_react_rails_prerenderer
  # ...
end
</code></pre>

<p>Then, you can access <code>react_rails_prerenderer</code> in the controller action:</p>

<pre><code class="ruby">def show
  js_context = react_rails_prerenderer.context
  js_context.exec(js_setup_code)
  render :show
  js_context.exec(js_teardown_code)
end
</code></pre>

<p>That way, you can properly prepare &amp; clean up a JS VM for server rendering.</p>

<h2>Re-detect events</h2>

<p>Previously, <code>ReactRailsUJS</code> &ldquo;automatically&rdquo; detected which libraries you were using and hooked up to their events for rendering components.</p>

<p>It still checks for libraries during its initial load, but you can <em>also</em> re-check as needed:</p>

<pre><code class="js">// Check the global context for libraries like Turbolinks and hook up to them:
ReactRailsUJS.detectEvents()
</code></pre>

<p>This function removes previous event handlers, so it&rsquo;s safe to call anytime. (This was added in <code>2.0.2</code>.)</p>

<h2>Other Takeaways</h2>

<p>See the <a href="https://github.com/reactjs/react-rails/blob/master/CHANGELOG.md">changelog</a> for bug fixes and a new default server rendering configuration.</p>

<p>Webpacker is great! Setup was smooth and the APIs were clear and convenient. I&rsquo;m looking forward to using it more.</p>

<p>🍻 Here&rsquo;s to another major version of <code>react-rails</code>!</p>
]]></content>
  </entry>
  
</feed>
