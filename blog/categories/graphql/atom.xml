<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: GraphQL | Robert Mosolgo]]></title>
  <link href="http://rmosolgo.github.io/blog/categories/graphql/atom.xml" rel="self"/>
  <link href="http://rmosolgo.github.io/"/>
  <updated>2018-09-25T11:02:11-04:00</updated>
  <id>http://rmosolgo.github.io/</id>
  <author>
    <name><![CDATA[Robert Mosolgo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Updating GitHub to GraphQL 1.8.0]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/04/09/updating-github-to-graphql-1-dot-8-0/"/>
    <updated>2018-04-09T09:52:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/04/09/updating-github-to-graphql-1-dot-8-0</id>
    <content type="html"><![CDATA[<p>GraphQL 1.8.0 was designed and built largely as a part of my work at GitHub. Besides designing the <a href="http://graphql-ruby.org/schema/class_based_api">new Schema definition API</a>, I migrated our codebase to use it. Here are some field notes from my migration.</p>

<!-- more -->


<p>If you want to know more about the motivations behind this work, check out this <a href="/blog/2018/03/25/why-a-new-schema-definition-api/">previous post</a>.</p>

<p>Below, I&rsquo;ll cover:</p>

<ul>
<li>The Process: in general, how I went about migrating our code</li>
<li>The Upgrader: how to run it and roughly how it&rsquo;s organized</li>
<li>Custom Transforms: extensions I made for the upgrader to work on GitHub-specific code</li>
<li>Fixes By Hand: bits of code that needed more work (some of these could be automated, but aren&rsquo;t yet!)</li>
<li>Porting Relay Types: using the class-based API for connections and edges</li>
<li>Migrating DSL extensions: how to support custom GraphQL extension in the new API</li>
</ul>


<h2>The Process</h2>

<p>GitHub&rsquo;s type definitions are separated into folders by type, for example: <code>objects/</code>, <code>unions/</code>, <code>enums/</code> (and <code>mutations/</code>). I worked through them one folder at a time. The <code>objects/</code> folder was big, so I did it twenty or thirty files at a time.</p>

<p>I had to do <code>interfaces/</code> last because of the nature of the new class-based schema. Interfaces modules' methods can&rsquo;t be added to legacy-style GraphQL object types. So, by doing interfaces last, I didn&rsquo;t have to worry about this compatibility issue.</p>

<p>Now that I remember it, I did the schema <em>first</em>, and by hand. It was a pretty easy upgrade.</p>

<p>When I started each section, I created a base class by hand. (There is some automated support for this, but I didn&rsquo;t use it.) Then, I ran the upgrader on some files and tried to run the test suite. There were usually two kinds of errors:</p>

<ul>
<li>Parse- or load-time errors which prevented the app from booting</li>
<li>Runtime errors which resulted in unexpected behavior or raised errors</li>
</ul>


<p>More on these errors below.</p>

<p>After upgrading a section of the schema, I opened a PR for review from the team. This was crucial: since I was working at such a large scale, it was easy for me to miss the trees for the forest. My teammates caught a lot of things during the process!</p>

<p>After a review, the PR would be merged into master. Since GraphQL 1.8.0 supports incremental migration, I could work through the code in chunks without a long running branch or feature flags.</p>

<h2>About the Upgrader</h2>

<p>Here&rsquo;s an overview of how the upgrader works. After reading the overview, if you want some specific examples, check out the <a href="https://github.com/rmosolgo/graphql-ruby/blob/master/lib/graphql/upgrader/member.rb">source code</a>.</p>

<h3>Running The Upgrader</h3>

<p>The gem includes an auto-upgrader, spearheaded by the folks at <a href="https://hackerone.com">HackerOne</a> and refined during my use of it. It&rsquo;s encapsulated in a class, <code>GraphQL::Upgrader::Member</code>.</p>

<p>To use the upgrader, I added a Ruby script to the code base called <code>graphql-update.rb</code>:</p>

<pre><code class="ruby"># Usage:
#   ruby graphql-update.rb path/to/type_definition.rb
#
# Example:
#   # Upgrade `BlameRange`
#   ruby graphql-update.rb lib/platform/objects/blame_range.rb
#
#   # Upgrade based on a pattern (use quotes)
#   ruby graphql-update.rb "lib/platform/objects/blob_\*.rb"
#
#   # Upgrade one more file in this pattern (use quotes)
#   ruby graphql-update.rb 1 "lib/platform/objects/**.rb"

# Load the upgrader from local code, for easier trial-and-error development
# require "~/code/graphql-ruby/lib/graphql/upgrader/member"
# Load the upgrader from the Gem:
require "graphql/upgrader/member"

# Accept two arguments: next_files (optional), file_pattern (required)
file_pattern = ARGV[0]
if file_pattern =~ /\d+/
  next_files = file_pattern.to_i
  next_files_pattern = ARGV[1]
  "Upgrading #{next_files} more files in #{next_files_pattern}"
  filenames = Dir.glob(next_files_pattern)
else
  filenames = Dir.glob(file_pattern)
  next_files = nil
  puts "Upgrading #{filenames.join(", ")}"
end

# ...
# Lots of custom rules here, see below
# ...

CUSTOM_TRANSFORMS = {
  type_transforms: type_transforms,
  field_transforms: field_transforms,
  clean_up_transforms: clean_up_transforms,
  skip: CustomSkip,
}

upgraded = []
filenames.each do |filename|
  puts "Begin (#{filename})"
  # Read the file into a string
  original_text = File.read(filename)
  # Create an Upgrader with the set of custom transforms
  GraphQL::Upgrader::Member.new(original_text, **CUSTOM_TRANSFORMS)
  # Generate updated text
  transformed_text = upgrader.upgrade
  if transformed_text == original_text
    # No upgrade was performed
  else
    # If the upgrade was successful, update the source file
    File.write(filename, transformed_text)
    upgraded &lt;&lt; filename
  end
  puts "Done (#{filename})"
  if next_files &amp;&amp; upgraded.size &gt;= next_files
    # We've upgraded as many as we said we would
    break
  end
end
puts "Upgraded #{upgraded.size} files: \n#{upgraded.join("\n")}"
</code></pre>

<p>This script has two basic parts:</p>

<ul>
<li>Using <code>GraphQL::Upgrader::Member</code> with a set of custom transformations</li>
<li>Supporting code: accepting input, counting files, logging, etc</li>
</ul>


<p>In your own script, you can write whatever supporting code you want. The key part from GraphQL-Ruby is:</p>

<pre><code class="ruby"># Create an Upgrader with the set of custom transforms
GraphQL::Upgrader::Member.new(original_text, **CUSTOM_TRANSFORMS)
# Generate updated text
transformed_text = upgrader.upgrade
</code></pre>

<h3>The Pipeline</h3>

<p>The upgrader is structured as a pipeline: each step accepts a big string of input and returns a big string of output. Sometimes, a step does nothing and so its returned string is the same as the input string. In general, the transforms consist of two steps:</p>

<ul>
<li>Check whether the transform applies to the given input</li>
<li>If it does, copy the string and apply a find-and-replace to it (sometimes using RegExp, other times using the excellent <code>parser</code> gem.)</li>
</ul>


<p>You have a few options for customizing the transformation pipeline:</p>

<ul>
<li>Write new transforms and add them to the pipeline</li>
<li>Remove transforms from the pipeline</li>
<li>Re-use the built-in transforms, but give them different parameters, then replace the built-in one with your custom instance</li>
</ul>


<p>(The &ldquo;pipeline&rdquo; is just an array of instances or subclasses of <code>GraphQL::Upgrader::Transform</code>.)</p>

<p>We&rsquo;ll see cases of each below.</p>

<h3>Kinds of Transforms</h3>

<p>The upgrader accepts several types of transform pipelines:</p>

<pre><code class="ruby">CUSTOM_TRANSFORMS = {
  type_transforms: type_transforms,
  field_transforms: field_transforms,
  clean_up_transforms: clean_up_transforms,
  skip: CustomSkip,
}
</code></pre>

<ul>
<li><code>type_transforms</code> are run first, on the <em>entire</em> file.</li>
<li><code>field_transforms</code> are run second, but they receive <em>parts</em> of the type definition. They receive calls to <code>field</code>, <code>connection</code>, <code>return_field</code>, <code>input_field</code>, and <code>argument</code>. Fine-grained changes to field definition or argument definition go here.</li>
<li><code>clean_up_transforms</code> are run last, on the <em>entire</em> file. For example, there&rsquo;s a built-in <code>RemoveExcessWhitespaceTransform</code> which cleans up trailing spaces after other transforms have run.</li>
<li><code>skip:</code> has a special function: its <code>#skip?(input)</code> method is called and if it returns true, the text is not transformed at all. This allows the transformer to be idempotent: by default, if you run it on the same file over and over, it will update the file only <em>once</em>.</li>
</ul>


<h2>Custom Transforms</h2>

<p>Here are some custom transforms applied to our codebase.</p>

<h3>Handle a custom type-definition DSL</h3>

<p>We had a wrapper around <code>ObjectType.define</code> which attached metadata, linking the object type to a specific Rails model. The helper was called <code>define_active_record_type</code>. I wanted to take this:</p>

<pre><code class="ruby">module Platform
  module Objects
    Issue = define_active_record_type(-&gt; { ::Issue }) do
      # ...
    end
  end
end
</code></pre>

<p>And make it this:</p>

<pre><code class="ruby">module Platform
  module Objects
    class Issue &lt; Platform::Objects::Base
      model_name "Issue"
      # ...
    end
  end
end
</code></pre>

<p>Fortunately, this can be done with a pretty straightforward regular expression substitution. Here&rsquo;s the transform:</p>

<pre><code class="ruby"># Create a custom transform for our `define_active_record_type` factory:
class ActiveRecordTypeToClassTransform &lt; GraphQL::Upgrader::Transform
  # Capture: leading whitespace, type name, model name
  FIND_PATTERN = /^( +)([a-zA-Z_0-9:]*) = define_active_record_type\(-&gt; ?\{ ?:{0,2}([a-zA-Z_0-9:]*) ?\} ?\) do/
  # Restructure as a class, using the leading whitespace and adding the `model_name` DSL
  REPLACE_PATTERN = "\\1class \\2 &lt; Platform::Objects::Base\n\\1  model_name \"\\3\""

  def apply(input_text)
    # It's safe to apply this transform to _all_ input,
    # since it's a no-op if `FIND_PATTERN` is missing.
    input_text.sub(FIND_PATTERN, REPLACE_PATTERN)
  end
end
</code></pre>

<p>Then, in <code>graphql-update.rb</code>, this transform was put <em>first</em> in the list:</p>

<pre><code class="ruby"># graphql-update.rb
type_transforms = GraphQL::Upgrader::Member::DEFAULT_TYPE_TRANSFORMS.dup
type_transforms.unshift(ActiveRecordTypeToClassTransform)
</code></pre>

<p>Also, for this to work, I added the <code>def self.model_name(name)</code> helper to the base class.</p>

<h3>Renaming a Custom Field Method</h3>

<p>We have a helper for adding URL fields called <code>define_url_field</code>. I decided to rename this to <code>url_fields</code>, since these days it creates <em>two</em> fields.</p>

<p>The arguments are the same, so it was a simple substitution:</p>

<pre><code class="ruby">class UrlFieldTransform &lt; GraphQL::Upgrader::Transform
  def apply(input_text)
    # Capture the leading whitespace and the rest of the line,
    # then insert the new name where the old name used to be
    input_text.gsub(/^( +)define_url_field( |\()/, "\\1url_fields\\2")
  end
end
</code></pre>

<p>This transform didn&rsquo;t interact with any other transforms, so I added it to <code>clean_up_transforms</code>, so it would run last:</p>

<pre><code class="ruby"># Make a copy of the built-in arry
clean_up_transforms = GraphQL::Upgrader::Member::DEFAULT_CLEAN_UP_TRANSFORMS.dup
# Add my custom transform to the end of the array
clean_up_transforms.push(UrlFieldTransform)
</code></pre>

<h3>Moving DSL methods to keywords</h3>

<p>We have a few DSL methods that, at the time, were easier to implement as keyword arguments. (Since then, the API has changed a bit. You can implement DSL methods on your fields by extending <code>GraphQL::Schema::Field</code> and setting that class as <code>field_class</code> on your base Object, Interface and Mutation classes.)</p>

<p>I wanted to transform:</p>

<pre><code class="ruby">field :secretStuff, types.String do
  visibility :secret
end
</code></pre>

<p>To:</p>

<pre><code class="ruby">field :secretStuff, types.String, visibility: :secret
</code></pre>

<p>(Later, a built-in upgrader would change <code>secretStuff</code> to <code>secret_stuff</code> and <code>types.String</code> to <code>String, null: true</code>.)</p>

<p>To accomplish this, I reused a built-in transform, <code>ConfigurationToKwargTransform</code>, adding it to <code>field_transforms</code>:</p>

<pre><code class="ruby"># Make a copy of the built-in list of defaults
field_transforms = GraphQL::Upgrader::Member::DEFAULT_FIELD_TRANSFORMS.dup
# Put my custom transform at the beginning of the list
field_transforms.unshift(GraphQL::Upgrader::ConfigurationToKwargTransform.new(kwarg: "visibility"))
</code></pre>

<p>In fact, there were several configuration methods moved this way.</p>

<h3>Custom Skip</h3>

<p>As I was working through the code, some files were tougher than others. So, I decided to skip them. I decided that a magic comment:</p>

<pre><code class="ruby"># @skip-auto-upgrade
</code></pre>

<p>would cause a file to be skipped. To implement this, I made a custom skip class:</p>

<pre><code class="ruby">class CustomSkip &lt; GraphQL::Upgrader::SkipOnNullKeyword
  def skip?(input_text)
    super(input_text) || input_text.include?("@skip-auto-upgrade")
  end
end
</code></pre>

<p>And passed it as <code>skip:</code> to the upgrader. Then, later, I removed the comment and tried again. (Fortunately, my procrastination paid off because the upgrader was improved in the meantime!)</p>

<h2>Fixes by Hand</h2>

<p>As I worked, I improved the upgrader to cover as many cases as I could, but there are still a few cases that I had to upgrade by hand. I&rsquo;ll list them here. If you&rsquo;re really dragged down by them, consider opening an issue on GraphQL-Ruby to talk about fixing them. I&rsquo;m sure they <em>can</em> be fixed, I just didn&rsquo;t get to it!</p>

<p>If you want to fix one of these issues, try to replicate the issue by adding to an example <code>spec/fixtures/upgrader</code> and then getting a failing test. Then, you could update the upgrader code to fix that broken test.</p>

<h3>Accessing Arguments By Method</h3>

<p>Arguments could be accessed by method to avoid typos. However, now, since arguments are a Ruby keyword hash, they don&rsquo;t have methods corresponding to their keys.</p>

<p>Unfortunately, the upgrader doesn&rsquo;t do anything about this, it just leaves them there and you get a <code>NoMethodError</code> on <code>Hash</code>.</p>

<p>This could almost certainly be fixed by improving this find-and-replace in <code>ResolveProcToMethodTransform</code>:</p>

<pre><code class="ruby"># Update Argument access to be underscore and symbols
# Update `args[...]` and `args.key?`
method_body = method_body.gsub(/#{args_arg_name}(?&lt;method_begin&gt;\.key\?\(?|\[)["':](?&lt;arg_name&gt;[a-zA-Z0-9_]+)["']?(?&lt;method_end&gt;\]|\))?/) do
 # ...
end
</code></pre>

<p>It only updates a few methods on <code>args</code>, but I bet a similar find-and-replace could replace <em>other</em> method calls, too.</p>

<h3>Argument Usages Outside of Type Definitions</h3>

<p>Sometimes, we take GraphQL arguments and pass them to helper methods:</p>

<pre><code class="ruby">resolve -&gt;(obj, args, ctx) {
  Some::Helper.call(obj, args)
}
</code></pre>

<p>However when this was transformed to:</p>

<pre><code class="ruby">def do_stuff(**arguments)
  Some::Helper.call(@object, arguments)
end
</code></pre>

<p>It would break, because the new <code>arguments</code> value is a Ruby hash with underscored, symbol keys. So, if <code>Some::Helper</code> was using camelized strings to get values, it would stop working.</p>

<p>The upgrader can&rsquo;t really do anything there, since it&rsquo;s not analyzing the codebase. In my case, these were readily apparent because of failing tests, so I went and fixed them.</p>

<h3>context.add_error</h3>

<p>We have some fields that add to the <code>"errors"</code> key <em>and</em> return values, they used <code>ctx.add_error</code> to do so:</p>

<pre><code class="ruby">resolve -&gt;(obj, args, ctx) {
  begin
    obj.count_things
  rescue BackendIsBrokenError
    ctx.add_error(GraphQL::ExecutionError.new("Not working!"))
    0
  end
}
</code></pre>

<p>When upgraded, it doesn&rsquo;t work quite right:</p>

<pre><code class="ruby">def count_things
  begin
    @object.count_things
  rescue BackendIsBrokenError
    @context.add_error(GraphQL::ExecutionError.new("Not working!"))
    0
  end
end
</code></pre>

<p>(If you don&rsquo;t have to return a value, use <code>raise</code> instead, then you can stop reading this part!)</p>

<p>The problem is that <code>@context</code> is not a <em>field-specific</em> context anymore. Instead, it&rsquo;s the query-level context. (This is downside of the new API: we don&rsquo;t have a great way to pass in the field context anymore.)</p>

<p>To address this kind of issues, <code>field</code> accepts a keyword called <code>extras:</code>, which contains a array of symbols. In the case above, we could use <code>:execution_errors</code>:</p>

<pre><code class="ruby">field :count_things, Integer, null: false, extras: [:execution_errors]
def count_things(execution_errors:)
  @object.count_things
rescue BackendIsBrokenError
  execution_errors.add("Not working!")
  0
end
</code></pre>

<p>So, <code>execution_errors</code> was injected into the field as a keyword. It <em>is</em> field-level, so adding errors there works as before.</p>

<p>Other extras are <code>:irep_node</code>, <code>:parent</code>, <code>:ast_node</code>, and <code>:arguments</code>. It&rsquo;s a bit of a hack, but we need <em>something</em> for this!</p>

<h3>Accessing Connection Arguments</h3>

<p>By default, connection arguments (like <code>first</code>, <code>after</code>, <code>last</code>, <code>before</code>) are <em>not</em> passed to the Ruby methods for implementing fields. This is because they&rsquo;re generally used by the automagical (😖) connection wrappers, not the resolve functions.</p>

<p>But, sometimes you just <em>need</em> those old arguments!</p>

<p>If you use <code>extras: [:arguments]</code>, the legacy-style arguments will be injected as a keyword:</p>

<pre><code class="ruby"># `arguments` is the legacy-style Query::Arguments instance
# `field_arguments` is a Ruby hash with symbol, underscored keys.
def things(arguments:, **field_arguments)
  arguments[:first] # =&gt; 5
  # ...
end
</code></pre>

<h3>Fancy String Descriptions</h3>

<p>The upgrader does fine when the description is a <code>"..."</code> or <code>'...'</code> string. But in other cases, it was a bit wacky.</p>

<p>Strings built up with <code>+</code> or <code>\</code> always broke. I had to go back by hand and join them into one string.</p>

<p>Heredoc strings often <em>worked</em>, but only by chance. For example:</p>

<pre><code class="ruby">field :stuff, types.Int do
  description &lt;&lt;~MD
    Here's the stuff
  MD
end
</code></pre>

<p>Would be transformed to:</p>

<pre><code class="ruby">field :stuff, Integer, description: &lt;&lt;~MD, null: true
    Here's the stuff
  MD
</code></pre>

<p>This is valid Ruby, but a bit tricky. This could definitely be improved: since I started my project, GraphQL 1.8 was extended to support <code>description</code> as a <em>method</em> as well as a keyword. So, the upgrader could be improved to leave descriptions in place if they&rsquo;re fancy strings.</p>

<h3>Removed Comments From the Start of Resolve Proc</h3>

<p>I hacked around with the <code>parser</code> gem to transform <code>resolve</code> procs into instance methods, but there&rsquo;s a bug. A proc like this:</p>

<pre><code class="ruby">resolve -&gt;(obj, args, ctx) {
  # Do stuff
  obj.do_stuff { stuff }
}
</code></pre>

<p>Will be transformed to:</p>

<pre><code class="ruby">def stuff
  @object.do_stuff { stuff }
end
</code></pre>

<p>Did you see how the comment was removed? I think I&rsquo;ve somehow wrongly detected the start of the proc body, so that the comment was left out.</p>

<p>In my case, I re-added those comments by hand. But it could probably be fixed in <code>GraphQL::Upgrader::ResolveProcToMethodTransform</code>.</p>

<h3>Hash Reformating?</h3>

<p>I&rsquo;m not sure why, but sometimes a hash of arguments like:</p>

<pre><code class="ruby">obj.do_stuff(
  a: 1,
  b: 2,
  c: 3,
  d: 4,
)
</code></pre>

<p>would be reorganized to</p>

<pre><code class="ruby">obj.do_stuff(
  a: 1,
  b: 2, c: 3, d: 4,
)
</code></pre>

<p>I have no idea why, and I didn&rsquo;t look into it, I just fixed it by hand.</p>

<h3>Issues with Connection DSL</h3>

<p>We have a DSL for making connections, like:</p>

<pre><code class="ruby">Connections.define(Objects::Issue)
</code></pre>

<p>Sometimes, when this connection was inside a proc, it would be wrongly transformed to:</p>

<pre><code class="ruby">field :issues, Connections.define(Objects::Issue) }, ,null: true
</code></pre>

<p>This was invalid Ruby, so the app wouldn&rsquo;t boot, and I would fix it by hand.</p>

<h2>Porting Relay Types</h2>

<p>Generating connection and edge types with the <code>.connection_type</code>/<code>.define_connection</code> and <code>.edge_type</code>/<code>.define_edge</code> methods will work fine with the new API, but if you want to migrate them to classes, you can do it.</p>

<p>It&rsquo;s on my radar because I want to remove our DSL extensions, and that requires updating our custom connection edge types.</p>

<p>Long story, short, it Just Work™ed with the class-based API. The approach was:</p>

<ul>
<li>Add a base class inheriting from our <code>BaseObject</code></li>
<li>Use the new base class&rsquo;s <code>def self.inherited</code> hook to add connection- and edge-related behaviors</li>
<li>Run the upgrader on edge and connection types, then go back and do some manual find-and-replaces to make them work right</li>
</ul>


<p>So, I will share my base classes in case that helps. Sometime it will be nice to upstream this to GraphQL-Ruby, but I&rsquo;m not sure how to do it now.</p>

<p>Base connection class:</p>

<pre><code class="ruby">module Platform
  module Connections
    class Base &lt; Platform::Objects::Base
      # For some reason, these are needed, they call through to the underlying connection wrapper.
      extend Forwardable
      def_delegators :@object, :cursor_from_node, :parent

      # When this class is extended, add the default connection behaviors.
      # This adds a new `graphql_name` and description, and searches
      # for a corresponding edge type.
      # See `.edge_type` for how the fields are added.
      def self.inherited(child_class)
        # We have a convention that connection classes _don't_ end in `Connection`, which
        # is a bit confusing and results in naming conflicts.
        # To avoid a GraphQL conflict, override `graphql_name` to end in `Connection`.
        type_name = child_class.name.split("::").last
        child_class.graphql_name("#{type_name}Connection")

        # Use `require_dependency` so that the types will be loaded, if they exist.
        # Otherwise, `const_get` may reach a top-level constant (eg, `::Issue` model instead of `Platform::Objects::Issue`).
        # That behavior is removed in Ruby 2.5, then we can remove these require_dependency calls too.
        begin
          # Look for a custom edge whose name matches this connection's name
          require_dependency "lib/platform/edges/#{type_name.underscore}"
          wrapped_edge_class = Platform::Edges.const_get(type_name)
          wrapped_node_class = wrapped_edge_class.fields["node"].type
        rescue LoadError =&gt; err
          # If the custom edge file doesn't exist, look for an object
          begin
            require_dependency "lib/platform/objects/#{type_name.underscore}"
            wrapped_node_class = Platform::Objects.const_get(type_name)
            wrapped_edge_class = wrapped_node_class.edge_type
          rescue LoadError =&gt; err
            # Assume that `edge_type` will be called later
          end
        end

        # If a default could be found using constant lookups, generate the fields for it.
        if wrapped_edge_class
          if wrapped_edge_class.is_a?(GraphQL::ObjectType) || (wrapped_edge_class.is_a?(Class) &amp;&amp; wrapped_edge_class &lt; Platform::Edges::Base)
            child_class.edge_type(wrapped_edge_class, node_type: wrapped_node_class)
          else
            raise TypeError, "Missed edge type lookup, didn't find a type definition: #{type_name.inspect} =&gt; #{wrapped_edge_class.inspect}"
          end
        end
      end

      # Configure this connection to return `edges` and `nodes` based on `edge_type_class`.
      #
      # This method will use the inputs to create:
      # - `edges` field
      # - `nodes` field
      # - description
      #
      # It's called when you subclass this base connection, trying to use the
      # class name to set defaults. You can call it again in the class definition
      # to override the default (or provide a value, if the default lookup failed).
      def self.edge_type(edge_type_class, edge_class: GraphQL::Relay::Edge, node_type: nil)
        # Add the edges field, can be overridden later
        field :edges, [edge_type_class, null: true],
          null: true,
          description: "A list of edges.",
          method: :edge_nodes,
          edge_class: edge_class

        # Try to figure out what the node type is, if it wasn't provided:
        if node_type.nil?
          if edge_type_class.is_a?(Class)
            node_type = edge_type_class.fields["node"].type
          elsif edge_type_class.is_a?(GraphQL::ObjectType)
            # This was created with `.edge_type`
            node_type = Platform::Objects.const_get(edge_type_class.name.sub("Edge", ""))
          else
            raise ArgumentError, "Can't get node type from edge type: #{edge_type_class}"
          end
        end

        # If it's a non-null type, remove the wrapper
        if node_type.respond_to?(:of_type)
          node_type = node_type.of_type
        end

        # Make the `nodes` shortcut field, which can be overridden later
        field :nodes, [node_type, null: true],
          null: true,
          description: "A list of nodes."

        # Make a nice description
        description("The connection type for #{node_type.graphql_name}.")
      end

      field :page_info, GraphQL::Relay::PageInfo, null: false, description: "Information to aid in pagination."

      # By default this calls through to the ConnectionWrapper's edge nodes method,
      # but sometimes you need to override it to support the `nodes` field
      def nodes
        @object.edge_nodes
      end
    end
  end
end
</code></pre>

<p>Base edge class:</p>

<pre><code class="ruby">module Platform
  module Edges
    class Base &lt; Platform::Objects::Base
      # A description which is inherited and may be overridden
      description "An edge in a connection."

      def self.inherited(child_class)
        # We have a convention that edge classes _don't_ end in `Edge`,
        # which is a little bit confusing, and would result in a naming conflict by default.
        # Avoid the naming conflict by overriding `graphql_name` to include `Edge`
        wrapped_type_name = child_class.name.split("::").last
        child_class.graphql_name("#{wrapped_type_name}Edge")
        # Add a default `node` field, assuming the object type name matches.
        # If it doesn't match, you can override this in subclasses
        child_class.field :node, "Platform::Objects::#{wrapped_type_name}", null: true, description: "The item at the end of the edge."
      end

      # A cursor field which is inherited
      field :cursor, String,
        null: false,
        description: "A cursor for use in pagination."
    end
  end
end
</code></pre>

<h2>Migrating DSL Extensions</h2>

<p>We have several extensions to the GraphQL-Ruby <code>.define</code> DSL, for example, <code>visibility</code> controls who can see certain types and fields and <code>scopes</code> maps OAuth scopes to GraphQL types.</p>

<p>The difficulty in porting extensions comes from the implementation details of the new API. For now, definition classes are factories for legacy-style type instances. Each class has a <code>.to_graphql</code> method which is called <em>once</em> to return a legacy-style definition. To maintain compatibility, you have to either:</p>

<ul>
<li>Modify the derived legacy-style definition to reflect configurations on the class-based definition; OR</li>
<li>Update your runtime code to <em>stop</em> checking for configurations on the legacy-style definition and <em>start</em> checking for configurations on the class-based definition.</li>
</ul>


<p>Eventually, legacy-style definitions will be phased out of GraphQL-Ruby, but for now, they both exist in this way in order to maintain backwards compatibility and gradual adoptability.</p>

<p>In the mean time, you can go between class-based and legacy-style definitions using <code>.graphql_defintion</code> and <code>.metadata[:type_class]</code>, for example:</p>

<pre><code class="ruby">class Project &lt; BaseObject
  # ...
end

legacy_type = Project.graphql_definition
# #&lt;GraphQL::ObjectType&gt; instance
legacy_type.metadata[:type_class]
# `Project` class
</code></pre>

<h3>The Easy Way: <code>.redefine</code></h3>

<p>The easiest way to retain compatibility is to:</p>

<ul>
<li>Add a class method to your base classes which accept some configuration and put it in instance variables</li>
<li>Override <code>.to_graphql</code> to call super, and then pass the configuration to <code>defn.redefine(...)</code>, then return the redefined type.</li>
</ul>


<p>After my work on our code, I extracted this into a <a href="http://graphql-ruby.org/type_definitions/extensions.html#customization-compatibility">backport of <code>accepts_definition</code></a></p>

<p>You can take that approach for a try, for example:</p>

<pre><code class="ruby">class BaseObject &lt; GraphQL::Schema::Object
  # Add a configuration method
  def self.visibility(level)
    @visibility = level
  end

  # Re-apply the configuration
  def self.to_graphql
    type_defn = super
    # Call through to the old extension:
    type_defn = type_defn.redefine(visibilty: @visibility)
    # Return the redefined type:
    type_defn
  end
end

# Then, use it in type definitions:
class Post &lt; BaseObject
  visibility(:secret)
end
</code></pre>

<h3>The Hard Way: <code>.metadata[:type_class]</code></h3>

<p>An approach I haven&rsquo;t tried yet, but I will soon, is to move the &ldquo;source of truth&rdquo; to the the class-based definition. The challenge here is that class-based definitions are not really used during validation and execution, so how can you reach configuration values on those classes?</p>

<p>The answer is that if a legacy-style type was derived from a class, that class is stored as <code>metadata[:type_class]</code>. For example:</p>

<pre><code class="ruby">class Project &lt; BaseObject
  # ...
end
legacy_defn = Project.graphql_definition # Instance of GraphQL::ObjectType, just like `.define`
legacy_defn.metadata[:type_class] # `Project` class from above
</code></pre>

<p>So, you could update runtime code to read configurations from <code>type_defn.metadata[:type_class]</code>.</p>

<p>Importantly, <code>metadata[:type_class]</code> will be <code>nil</code> if the type <em>wasn&rsquo;t</em> derived from a class, so this approach is tough to use if some definitions are still using the <code>.define</code> API.</p>

<p>I haven&rsquo;t implemented this yet, but I will be doing it in the next few weeks so we can simplify our extensions and improve boot time.</p>

<h2>The End</h2>

<p>I&rsquo;m still wrapping up some loose ends in the codebase, but I thought I&rsquo;d share these notes in case they help you in your upgrade. If you run into trouble on anything mentioned here, please <a href="https://github.com/rmosolgo/graphql-ruby/issues/new">open an issue</a> on GraphQL-Ruby! I really want to support a smooth transition to this new API.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why a New Schema Definition API?]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/03/25/why-a-new-schema-definition-api/"/>
    <updated>2018-03-25T13:59:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/03/25/why-a-new-schema-definition-api</id>
    <content type="html"><![CDATA[<p>GraphQL-Ruby <code>1.8.0</code> will have a new class-based API for defining your schema. Let&rsquo;s investigate the design choices in the new API.</p>

<!-- more -->


<p>The new API is backwards-compatible and can coexist with type definitions in the old format. See <a href="https://github.com/rmosolgo/graphql-ruby/blob/1.8-dev/guides/schema/class_based_api.md#compatibility--migration-overview">the docs</a> for details. <code>1.8.0.pre</code> versions are available on RubyGems now and are very stable &ndash; that&rsquo;s what we&rsquo;re running at GitHub!</p>

<h2>Problems Worth Fixing</h2>

<p>Since starting at GitHub last May, I&rsquo;ve entered into the experience of a huge-scale GraphQL system. Huge scale in lots of ways: huge schema, huge volume, and huge developer base. One of the problems that stood out to me (and to lots of us) was that GraphQL-Ruby simply <em>didn&rsquo;t help</em> us be productive. Elements of schema definition hindered us rather than helped us.</p>

<p>So, our team set out on remaking the GraphQL-Ruby schema definition API. We wanted to address a few specific issues:</p>

<ul>
<li><strong>Familiarity</strong>. GraphQL-Ruby&rsquo;s schema definition API reflected GraphQL and JavaScript more than it reflected Ruby. (The JavaScript influence comes from <code>graphql-js</code>, the reference implementation.) Ruby developers couldn&rsquo;t bring their usual practices into schema development; instead, they had to learn a bunch of new APIs and figure out how to work them together.</li>
<li><strong>Rails Compatibility</strong>, especially constant loading. A good API would work seamlessly with Rails development configurations, but the current API has some gotchas regarding circular dependencies and reloading.</li>
<li><strong>Hackability</strong>. Library code is fine <em>until it isn&rsquo;t</em>, and one of the best (and worst) things about Ruby is that all code is open to extension (or monkey-patching 🙈). At best, this means that library users can customize the library code in straightforward ways to better suit their use cases. However, GraphQL-Ruby didn&rsquo;t support this well: to support special use cases, customizations had to be hacked in in odd ways that were hard to maintain and prone to breaking during gem updates.</li>
</ul>


<p>Besides all that, we needed a <em>safe</em> transition, so it had to support a gradual adoption.</p>

<p>After trying a few different possibilities, the team decided to take a class-based approach to defining GraphQL schemas. I&rsquo;m really thankful for their support in the design process, and I&rsquo;m indebted to the folks at Shopify, who used a class-based schema definition system from the start (as a layer on top of GraphQL-Ruby) and <a href="https://www.youtube.com/watch?v=Wlu_PWCjc6Y">presented their work</a> early on.</p>

<h2>The new API, from 10,000 feet</h2>

<p>In short, GraphQL types used to be singleton instances, built with a <a href="https://twitter.com/krainboltgreene/status/971797438070599680">block-based API</a>:</p>

<pre><code class="ruby">Types::Post = GraphQL::ObjectType.define {
  # ...
}
</code></pre>

<p>Now, GraphQL types are classes, with a DSL implemented as class methods:</p>

<pre><code class="ruby">class Types::Post
  # ...
end
</code></pre>

<p>Field resolution was previously defined using Proc literals:</p>

<pre><code class="ruby">field :comments, types[Types::Comments] do
  argument :orderBy, Types::CommentOrder
  resolve -&gt;(obj, args, ctx) {
    obj.comments.order(args[:orderBy])
  }
end
</code></pre>

<p>Now, field resolution is defined with an instance method:</p>

<pre><code class="ruby">field :comments, [Types::Comments], null: true do
  argument :order_by, Types::CommentOrder, required: false
end

def comments(order_by: nil)
  object.comments.order(order_by)
end
</code></pre>

<p>How does this address the issues listed above?</p>

<h2>More Familiarity</h2>

<p>First, using classes reduces the &ldquo;WTF&rdquo; factor of GraphQL definition code. A seasoned Ruby developer might (rightly) smell foul play and reject GraphQL-Ruby on principle. (I was not seasoned enough to detect this when I designed the API!)</p>

<p>Proc literals are rare in Ruby, but common in GraphQL-Ruby&rsquo;s <code>.define { ... }</code> API. Their lexical scoping rules are different than method scoping rules, making it hard to remember what <em>was</em> and <em>wasn&rsquo;t</em> in scope during field resolution (for example, what was <code>self</code>?). To make matters worse, <em>some</em> of the blocks in the <code>.define</code> API were <code>instance_eval</code>&rsquo;d, so their <code>self</code> would be overridden. Practically, this meant that typos in development resulted in strange <code>NoMethodError</code>s.</p>

<p>Proc literals also have performance downsides: they&rsquo;re not optimized by CRuby, so they&rsquo;re <a href="https://gist.github.com/rmosolgo/6c6a7d787e0f1666f4c6d858c8402a01#gistcomment-1843329">slower than method calls</a>. Since they capture a lexical scope, they may also have <a href="https://github.com/github/graphql-client/pull/139">unexpected impacts on memory footprint</a> (any local variable may be retained, since it might be accessed by the proc). The solutions here are simple: just use methods, the way Ruby wants you to! 😬</p>

<p>In the new class-based API, there are no proc literals (although they&rsquo;re supported for compatibility&rsquo;s sake). There are some <code>instance_eval</code>&rsquo;d blocks (<code>field(...) { }</code>, for example), but field resolution is <em>just an instance method</em> and the type definition is a normal class, so module scoping works normally. (Contrast that with the constant assignment in <code>Types::Post = GraphQL::ObjectType.define { ... }</code>, where no module scope is used). Several hooks that were previously specified as procs are now class methods, such as <code>resolve_type</code> and <code>coerce_input</code> (for scalars).</p>

<p>Overriding <code>!</code> is another particular no-no I&rsquo;m correcting. At the time, I thought, &ldquo;what a cool way to bring a GraphQL concept into Ruby!&rdquo; This is because GraphQL non-null types are expressed with <code>!</code>:</p>

<pre><code class="ruby"># This field always returns a User, never `null`
author: User!
</code></pre>

<p>So, why not express the concept with Ruby&rsquo;s <code>!</code> method (which is usually used for negation)?</p>

<pre><code class="ruby">field :author, !User
</code></pre>

<p>As it turns out, there are several good reasons for <em>why not</em>!</p>

<ul>
<li>Overriding <code>!</code> breaks the negation operator. ActiveSupport&rsquo;s <code>.present?</code> didn&rsquo;t work with type objects, because <code>!</code> didn&rsquo;t return <code>false</code>, it returned a non-null type.</li>
<li>Overriding the <code>!</code> operator throws people off. When a newcomer sees GraphQL-Ruby sample code, they have a WTF moment, followed by the dreadful memory (or discovery) that Ruby allows you to override <code>!</code>.</li>
<li>There&rsquo;s very little value in importing GraphQL concepts into Ruby. GraphQL-Ruby developers are generally seasoned Ruby developers who are just learning GraphQL, so they don&rsquo;t gain anything by the similarity to GraphQL.</li>
</ul>


<p>So, overriding <code>!</code> didn&rsquo;t deliver any value, but it did present a roadblock to developers and break some really essential code.</p>

<p>In the new API, nullability is expressed with the options <code>null:</code> and <code>required:</code> instead of with <code>!</code>. (But, you can re-activate that override for compatibility while you transition to the new API.)</p>

<p>By switching to Ruby&rsquo;s happy path of classes and methods, we can help Ruby developers feel more at home in GraphQL definitions. Additionally, we avoid some unfamiliar gotchas of procs and clear a path for removing the <code>!</code> override.</p>

<h2>Rails Compatibility</h2>

<p>Rails' automatic constant loading is wonderful &hellip; until it&rsquo;s <em>not</em>! GraphQL-Ruby didn&rsquo;t play well with Rails' constant loading especially when it came to cyclical dependencies, and here&rsquo;s why.</p>

<p>Imagine a typical <code>.define</code>-style type definition, like this:</p>

<pre><code class="ruby">Types::T = GraphQL::ObjectType.define { ... }
</code></pre>

<p>We&rsquo;re assigning the constant <code>Types::T</code> to the return value of <code>.define { ... }</code>. Consequently, the constant is not defined <em>until</em> <code>.define</code> returns.</p>

<p>Let&rsquo;s expand the example to two type definitions:</p>

<pre><code class="ruby">Types::T1 = GraphQL::ObjectType.define { ... }
Types::T2 = GraphQL::ObjectType.define { ... }
</code></pre>

<p>If <code>T1</code> depends on <code>T2</code>, <em>and</em> <code>T2</code> depends on <code>T1</code>, how can this work? (For example, imagine a <code>Post</code> type whose <code>author</code> field returns a <code>User</code>, and a <code>User</code> type whose <code>posts</code> field returns a list of <code>Post</code>s. This kind of cyclical dependency is common!) GraphQL-Ruby&rsquo;s solution was to adopt a JavaScriptism, a <em>thunk</em>. (Technically, I guess it&rsquo;s a functional programming-ism, but I got it from <code>graphql-js</code>.) A <em>thunk</em> is an anonymous function used to defer the resolution of a value. For example, if we have code like this:</p>

<pre><code class="ruby">field :author, Types::User
# NameError: uninitialized constant Types::User
</code></pre>

<p>GraphQL-Ruby would accept this:</p>

<pre><code class="ruby">field :author, -&gt; { Types::User }
# Thanks for the function, I will call it later to get the value!
</code></pre>

<p>Later, GraphQL-Ruby would <code>.call</code> the proc and get the value. At that type, <code>Types::User</code> would properly resolve to the correct type. This <em>worked</em> but it had two big downsides:</p>

<ul>
<li>It added an unfamiliar construct (<code>Proc</code>) in an unfamiliar context (a method argument), so it was frustrating and disorienting.</li>
<li>It added visual noise to the source code.</li>
</ul>


<p>How does switching to classes resolve this issue? To ask the same question, how come we don&rsquo;t experience this problem with normal Rails models?</p>

<p>Part of the answer has to do with <em>how classes are evaluated</em>. Consider two classes in two different files:</p>

<pre><code class="ruby"># app/graphql/types/post.rb
module Types
  class Post &lt; BaseObject
    field :author, Types::User, null: false
  end
end
# app/graphql/types/user.rb
module Types
  class User &lt; BaseObject
    field :posts, [Types::Post], null: false
  end
end
</code></pre>

<p>Notice that <code>Post</code> depends on <code>User</code>, and <code>User</code> depends on <code>Post</code>. The difference is how these lines are evaluated, and when the constants become defined. Here&rsquo;s the same code, with numbering to indicate the order that lines are evaluated:</p>

<pre><code class="ruby"># Let's assume that `Post` is loaded first.
# app/graphql/types/post.rb
module Types                                  # 1, evaluation starts here
  class Post &lt; BaseObject                     # 2, and naturally flows here, constant `Types::Post` is initialized as a class extending BaseObject
    field :author, Types::User, null: false   # 3, but when evaluating `Types::User`, jumps down below
  end                                         # 9, execution resumes here after loading `Types::User`
end                                           # 10
# app/graphql/types/user.rb
module Types                                  # 4, Rails opens this file looking for `Types::User`
  class User &lt; BaseObject                     # 5, constant `Types::User` is initialized
    field :posts, [Types::Post], null: false  # 6, this line finishes without jumping, because `Types::Post` is _already_ initialized (see `# 2` above)
  end                                         # 7
end                                           # 8
</code></pre>

<p>Since <code>Types::Post</code> is <em>initialized</em> first, then built-up by the following lines of code, it&rsquo;s available to <code>Types::User</code> in the case of a circular dependency. As a result, the thunk is not necessary.</p>

<p>This approach isn&rsquo;t a silver bullet &ndash; <code>Types::Post</code> is not fully initialized by the time <code>Types::User</code> needs it &ndash; but it reduces visual friction and generally plays nice with Rails out of the box.</p>

<h2>Hackability</h2>

<p>I&rsquo;ve used a naughty word here, but in fact, I&rsquo;m talking about something very good. Have you ever been stuck with some dependency that didn&rsquo;t quite fit your application? (Or, maybe you were stuck on an old version, or your app needed a new feature that wasn&rsquo;t quite supported by the library.) Like it or not, sometimes the only way forward in a case like that is to hack it: reopen classes, redefine methods, mess with the inheritance chain, etc. Yes, those choices come with maintenance downsides, but sometimes they&rsquo;re really the best way forward.</p>

<p>On the other hand, really flexible libraries are <em>ready</em> for you to come and extend them. For example, they might provide base classes for you to extend, with the assumption that you&rsquo;ll override and implement certain methods. In that case, the same hacking techniques listed above have found their time to shine.</p>

<p><code>ActiveRecord::Base</code> is a great example of both cases: plenty of libraries hack methods right into the built-in class (for example, <code>acts_as_{whatever}</code>), and also, lots of Rails apps use an <code>ApplicationRecord</code> class for their application-specific customizations.</p>

<p>Since GraphQL-Ruby didn&rsquo;t use the familiar arrangement of classes and methods, it was closed to this kind of extension. (Ok, you <em>could</em> do it, but it was a lot of work! And who wants to do that!?) In place of this, GraphQL-Ruby had yet-another-API for extending its DSL. Yet another thing to learn, with more Proc literals 😪.</p>

<p>Using classes simplifies this process because you can use familiar Ruby techniques to build your GraphQL schema. For example, if you want to share code between field resolvers, you can <code>include</code> a module and call its methods. If you want to make shorthands for common cases in your app, you can use your <code>Base</code> type classes. If you want to add special configuration to your types, you can use class methods. And, whenever that day should come, when you need to monkey-patch GraphQL-Ruby internals, I hope you&rsquo;ll be able to find the right spot to do it!</p>

<h2>Stay Classy</h2>

<p>GraphQL-Ruby is three years old now, and I&rsquo;ve learned a LOT during that time! I&rsquo;m really thankful for the opportunity to focus on <em>developer productivity</em> in the last few months, learning how I&rsquo;ve prevented it and working on ways to improve it. I hope to keep working on topics like this &ndash; how to make GraphQL more productive for Ruby developers &ndash; in the next year, especially, so if you have feedback on this new API, please <a href="https://github.com/rmosolgo/graphql-ruby/issues/new">open an issue</a> to share it!</p>

<p>I&rsquo;m excited to see how this new API changes the way people think about GraphQL in Ruby, and I hope it will foster more creativity and stability.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prototyping a GraphQL Schema From Definition With Ruby]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/03/17/prototyping-a-graphql-schema-from-definition-with-ruby/"/>
    <updated>2017-03-17T15:49:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/03/17/prototyping-a-graphql-schema-from-definition-with-ruby</id>
    <content type="html"><![CDATA[<p>GraphQL 1.5.0 includes a new way to define a schema: from a GraphQL definition.</p>

<!-- more -->


<p>In fact, loading a schema this way has been supported for while, but 1.5.0 adds the ability to specify field resolution behavior.</p>

<h2>GraphQL IDL</h2>

<p>Besides queries, GraphQL has an <em>interface definition language</em> (IDL) for expressing a schema’s structure. For example:</p>

<pre><code class="ruby">schema {
  query: Query
}

type Query {
  post(id: ID!): Post
}

type Post {
  title: String!
  comments: [Comment!]
}
</code></pre>

<p>You can turn a definition into a schema with <code>Schema.from_definition</code>:</p>

<pre><code class="ruby">schema_defn = "..."
schema = GraphQL::Schema.from_definition(schema_defn)
</code></pre>

<p>(By the way, the IDL is technically in <a href="https://github.com/facebook/graphql/pull/90">RFC stage</a>.)</p>

<h2>Resolvers</h2>

<p><code>Schema.from_definition</code> also accepts <code>default_resolve:</code> argument. It expects one of two inputs:</p>

<ul>
<li>A nested hash of type <code>Hash&lt;String =&gt; Hash&lt;String =&gt; #call(obj, args, ctx)&gt;&gt;</code>; or</li>
<li>An object that responds to <code>#call(type, field, obj, args, ctx)</code></li>
</ul>


<h4>Resolving with a Hash</h4>

<p>When you’re using a hash:</p>

<ul>
<li>The first key is a <em>type name</em></li>
<li>The second key is a <em>field name</em></li>
<li>The last value is a <em>resolve function</em> (<code>#call(obj, args, ctx)</code>)</li>
</ul>


<p>To get started, you can write the hash manually:</p>

<pre><code class="ruby">{
  "Query" =&gt; {
    "post" =&gt; -&gt;(obj, args, ctx) { Post.find(args[:id]) },
  },
  "Post" =&gt; {
    "title" =&gt; -&gt;(obj, args, ctx) { obj.title },
    "body" =&gt; -&gt;(obj, args, ctx) { obj.body },
    "comments" =&gt; -&gt;(obj, args, ctx) { obj.comments },
  },
}
</code></pre>

<p>But you can also reduce a lot of boilerplate by using a hash with default values:</p>

<pre><code class="ruby"># This hash will fall back to default implementation if another value isn't provided:
type_hash = Hash.new do |h, type_name|
  # Each type gets a hash of fields:
  h[type_name] = Hash.new do |h2, field_name|
    # Default resolve behavior is `obj.public_send(field_name, args, ctx)`
    h2[field_name] = -&gt;(obj, args, ctx) { obj.public_send(field_name, args, ctx) }
  end
end

type_hash["Query"]["post"] = -&gt;(obj, args, ctx) { Post.find(args[:id]) }

schema = GraphQL::Schema.from_definition(schema_defn, default_resolve: type_hash)
</code></pre>

<p>Isn’t that a nice way to set up a simple schema?</p>

<h4>Resolving with a Single Function</h4>

<p>You can provide a single callable that responds to <code>#call(type, field, obj, args, ctx)</code>. What a mouthful!</p>

<p>The <em>advantage</em> of that hefty method signature is that it’s enough to specify any resolution behavior you can imagine. For example, you could create a system where type modules were found by name, then methods were called by name:</p>

<pre><code class="ruby">module ExecuteGraphQLByConvention
  module_function
  # Find a Ruby module corresponding to `type`,
  # then call its method corresponding to `field`.
  def call(type, field, obj, args, ctx)
    type_module = Object.const_get(type.name)
    type_module.public_send(field.name, obj, args, ctx)
  end
end

schema = GraphQL::Schema.from_definition(schema_defn, default_resolve: ExecuteGraphQLByConvention)
</code></pre>

<p>So, a single function combined with Ruby’s flexibility and power opens a lot of doors!</p>

<p>Doesn’t it remind you a bit of method dispatch? The arguments are:</p>

<table>
<thead>
<tr>
<th>GraphQL Field Resolution </th>
<th> Method Dispatch</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>type</code> </td>
<td> class</td>
</tr>
<tr>
<td><code>field</code> </td>
<td> method</td>
</tr>
<tr>
<td><code>obj</code> </td>
<td> receiver</td>
</tr>
<tr>
<td><code>args</code> </td>
<td> method arguments</td>
</tr>
<tr>
<td><code>ctx</code> </td>
<td> runtime state (cf <a href="https://github.com/mruby/mruby/blob/master/include/mruby.h#L257"><code>mrb_state</code></a>, <a href="https://github.com/antirez/redis/blob/unstable/src/modules/INTRO.md"><code>RedisModuleCtx</code></a>, or <a href="http://erlang.org/doc/tutorial/nif.html"><code>ErlNifEnv</code></a>)</td>
</tr>
</tbody>
</table>


<h2>Special Configurations</h2>

<p>Some schemas need other configurations in order to run:</p>

<ul>
<li><code>resolve_type</code> to support union and interface types</li>
<li>schema plugins like <a href="https://rmosolgo.github.io/graphql-ruby/pro/monitoring">monitoring</a> or custom <a href="https://rmosolgo.github.io/graphql-ruby/schema/instrumentation">instrumentation</a></li>
</ul>


<p>To add these to a schema, use <code>.redefine</code>:
```ruby</p>

<h1>Extend the schema with new definitions:</h1>

<p>schema = schema.redefine {
  resolve_type ->(obj, ctx) { &hellip; }
  monitoring :appsignal
}
```</p>

<h2>What’s Next?</h2>

<p>Rails has proven that “Convention over Configuration” can be a very productive way to start new projects, so I’m interested in exploring convention-based APIs on top of this feature.</p>

<p>In the future, I’d like to add support for schema annotations in the form of directives, for example:</p>

<pre><code class="ruby">type Post {
  comments: [Comment!] @relation(hasMany: "comments")
}
</code></pre>

<p>These could be used to customize resolution behavior. Cool!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tracking Schema Changes with GraphQL-Ruby]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/03/16/tracking-schema-changes-with-graphql-ruby/"/>
    <updated>2017-03-16T20:16:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/03/16/tracking-schema-changes-with-graphql-ruby</id>
    <content type="html"><![CDATA[<p>One way to keep an eye on your GraphQL schema is to check the definition into source control.</p>

<!-- more -->


<p>When modifying shared code or reconfiguring, it can be hard to tell how the schema will <em>really</em> change. To help with this, set up a <strong>snapshot test</strong> for your GraphQL schema! This way:</p>

<ul>
<li>Changes will be clearly visible in GraphQL IDL</li>
<li>You can keep the IDL up-to-date by adding a test to your suite</li>
</ul>


<p>You can even track the schema from different contexts if you&rsquo;re using <a href="https://rmosolgo.github.io/graphql-ruby/pro/authorization"><code>GraphQL::Pro</code>&rsquo;s authorization framework</a>.</p>

<p>This approach was first described in <a href="https://www.youtube.com/watch?v=Wlu_PWCjc6Y">GraphQL at Shopify</a>.</p>

<h2>Check It In</h2>

<p>Write a <strong>Rake task</strong> to get your schema&rsquo;s definition and write it to a file:</p>

<pre><code class="ruby"># lib/tasks/graphql.rake
rake dump_schema: :environment do
  # Get a string containing the definition in GraphQL IDL:
  schema_defn = MyAppSchema.to_definition
  # Choose a place to write the schema dump:
  schema_path = "app/graphql/schema.graphql"
  # Write the schema dump to that file:
  File.write(Rails.root.join(schema_path), schema_defn)
  puts "Updated #{schema_path}"
end
</code></pre>

<p>You can run it from terminal:</p>

<pre><code class="sh">$ bundle exec rake dump_schema
Updated app/graphql/schema.graphql
</code></pre>

<p>This updates the file in your repo. Go ahead and <strong>check it in</strong>!</p>

<pre><code class="sh">$ git add app/graphql/schema.graphql
$ git commit -m "Add GraphQL schema dump"
</code></pre>

<h2>Keep It Up to Date</h2>

<p>Any changes to the Ruby schema code must be reflected in the <code>.graphql</code> file. You can give yourself a reminder by adding a <strong>test case</strong> which asserts that the GraphQL definition is up-to-date:</p>

<pre><code class="ruby"># test/graphql/my_app_schema_test.rb
require "test_helper"

class MyAppSchemaTest &lt; ActiveSupport::TestCase
  def test_printout_is_up_to_date
    current_defn = MyAppSchema.to_definition
    printout_defn = File.read(Rails.root.join("app/graphql/schema.graphql"))
    assert_equal(current_defn, printout_defn, "Update the printed schema with `bundle exec rake dump_schema`")
  end
end
</code></pre>

<p>If the definition is stale, you&rsquo;ll get a failed test:</p>

<p><img src="/images/tracking_schema/test_failure.png" width="500"></p>

<p>This reminder is helpful in development and <em>essential</em> during code review!</p>

<h2>Review It</h2>

<p>Now that your schema definition is versioned along with your code, you can see changes during <strong>code review</strong>:</p>

<p><img src="/images/tracking_schema/code_review.png" width="600"></p>

<h2>Multiple Schema Dumps</h2>

<p>If your schema looks different to different users, you can track <em>multiple</em> schema dumps. This is helpful if:</p>

<ul>
<li>You&rsquo;re using the <code>:view</code> configuration of <a href="https://rmosolgo.github.io/graphql-ruby/pro/authorization"><code>GraphQL::Pro</code>&rsquo;s authorization</a></li>
<li>You&rsquo;re using <code>only:</code>/ <code>except:</code> to manually filter your schema</li>
</ul>


<p>Just provide the <code>context:</code> argument to <code>Schema.to_definition</code> as if you were running a query. (Also provide <code>only:</code>/<code>except:</code> if you use them.)</p>

<p>Print with a filter from the Rake task:</p>

<pre><code class="ruby"># lib/tasks/graphql.rake
task dump_schema: :environment do
  # ...
  admin_user = OpenStruct.new(admin?: true)
  admin_schema_dump = MyAppSchema.to_definition(context: { current_user: admin_user })
  admin_schema_path = "app/graphql/admin_schema.graphql"
  File.write(Rails.root.join(admin_schema_path), admin_schema_dump)
end
</code></pre>

<p>Test with a filter from the test case:</p>

<pre><code class="ruby">def test_printout_is_up_to_date
  # ...
  admin_user = OpenStruct.new(admin?: true)
  current_admin_defn = MyAppSchema.to_definition(context: { current_user: admin_user })
  printout_admin_defn = File.read(Rails.root.join("app/graphql/admin_schema.graphql"))
  assert_equal(current_admin_defn, printout_admin_defn, "Update the printed schema with `bundle exec rake dump_schema`")
end
</code></pre>

<p>Now you can keep an eye on the schema from several perspectives!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optimizing GraphQL-Ruby]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/03/08/optimizing-graphql-ruby/"/>
    <updated>2017-03-08T08:02:00-05:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/03/08/optimizing-graphql-ruby</id>
    <content type="html"><![CDATA[<p>Soon, <code>graphql-ruby</code> 1.5.0 will be released. Query execution will be ~70% faster than 1.3.0!</p>

<!-- more -->


<p>Let&rsquo;s look at how we reduced the execution time between those two versions. Thanks to <a href="https://github.com/theorygeek">@theorygeek</a> who optimized the middleware chain helped me pinpoint several other bottlenecks!</p>

<h2>The Benchmark</h2>

<p>To track GraphQL execution overhead, I <a href="https://github.com/rmosolgo/graphql-ruby/blob/master/benchmark/run.rb">execute the introspection query</a> on a <a href="https://github.com/rmosolgo/graphql-ruby/blob/master/spec/support/dummy/schema.rb">fixture schema</a> in graphql-ruby&rsquo;s test suite.</p>

<p>On GraphQL 1.3.0, the benchmark ran around 22.5 iterations per second:</p>

<p><img src="/images/optimizing_graphql_ruby/1-3-0-bench.png" width="500"></p>

<p>On <a href="https://github.com/rmosolgo/graphql-ruby/commit/943e68f40a11f3f809ecd8485282eccdd6a6991b">master</a>, it runs around 38 iterations per second:</p>

<p><img src="/images/optimizing_graphql_ruby/1-5-0-bench.png" width="500"></p>

<p>That&rsquo;s almost 1.7x faster!</p>

<pre><code class="ruby">38.0 / 22.5
# =&gt; 1.6888888888888889
</code></pre>

<p>So, how&rsquo;d we do it?</p>

<h2>Looking Under the Hood with RubyProf</h2>

<p>To find where time was spent, I turned to <a href="https://github.com/ruby-prof/ruby-prof">ruby-prof</a>. I <a href="https://github.com/rmosolgo/graphql-ruby/pull/579">wrapped GraphQL execution</a> with profiling and inspected the result:</p>

<pre><code class="text">Thread ID: 70149906635240
Fiber ID: 70149911114440
Total: 0.474618
Sort by: self_time

 %self      total      self      wait     child     calls  name
  4.60      0.074     0.022     0.000     0.052     6893  *Class#new
  3.99      0.019     0.019     0.000     0.000     8715  *GraphQL::Define::InstanceDefinable#ensure_defined
  3.13      0.015     0.015     0.000     0.000    25403   Module#===
  2.64      0.013     0.013     0.000     0.000     8813   Kernel#hash
  2.49      0.074     0.012     0.000     0.063     3496  *GraphQL::Schema::MiddlewareChain#call
  1.85      0.009     0.009     0.000     0.000     4184   GraphQL::Query::Context::FieldResolutionContext#query
  1.78      0.017     0.008     0.000     0.008     2141   #&lt;Module:0x007f9a18de37a8&gt;#type
  1.63      0.008     0.008     0.000     0.000     1960   GraphQL::Query::Context::FieldResolutionContext#initialize
  1.54      0.012     0.007     0.000     0.005     1748   GraphQL::Query#get_field
  1.53      0.014     0.007     0.000     0.006     1748   GraphQL::Query#arguments_for
  1.52      0.007     0.007     0.000     0.000     8356   Kernel#is_a?
  1.51      0.010     0.007     0.000     0.003     7523   Kernel#===
  1.44      0.022     0.007     0.000     0.015     1959   GraphQL::Query::Context::FieldResolutionContext#spawn
  1.32      0.012     0.006     0.000     0.006     1748   GraphQL::Execution::Lazy::LazyMethodMap#get
  1.31      0.010     0.006     0.000     0.003     1748   GraphQL::Execution::FieldResult#value=
  1.29      0.032     0.006     0.000     0.026     1748   GraphQL::Field#resolve
  1.25      0.042     0.006     0.000     0.037     1748   #&lt;Module:0x007f9a18de37a8&gt;#resolve
  1.16      0.015     0.006     0.000     0.010     1748   GraphQL::Execution::FieldResult#initialize
  1.06      0.010     0.005     0.000     0.005     2815   GraphQL::Schema::Warden#visible?
  1.05      0.014     0.005     0.000     0.009     1748   GraphQL::Schema::MiddlewareChain#initialize
  1.03      0.005     0.005     0.000     0.000     2815   &lt;Module::GraphQL::Query::NullExcept&gt;#call
  0.97      0.014     0.005     0.000     0.009      756   Hash#each_value
# ... truncated ...
</code></pre>

<p>A few things stood out:</p>

<ul>
<li>~5% of time was spent during ~7k calls to <code>Class#new</code>: this is time spent initializing new objects. I think initialization can also trigger garbage collection (if there&rsquo;s not a spot on the free list), so this may include GC time.</li>
<li>~4% of time was spent during ~9k calls to <code>InstanceDefinable#ensure_defined</code>, which is part of graphql-ruby&rsquo;s definition API. It&rsquo;s <em>all</em> overhead to support the definition API, 😿.</li>
<li>Several methods are called <code>1748</code> times. Turns out, this is <em>once per field in the response</em>.</li>
<li>With that in mind, <code>25,403</code> seems like a lot of calls to <code>Module#===</code>!</li>
</ul>


<h2>Reduce GC Pressure</h2>

<p>Since <code>Class#new</code> was the call with the most <code>self</code> time, I thought I&rsquo;d start there. What kind of objects are being allocated? We can filter the profile output:</p>

<pre><code class="text">~/code/graphql $ cat 130_prof.txt | grep initialize
  1.63      0.008     0.008     0.000     0.000     1960   GraphQL::Query::Context::FieldResolutionContext#initialize
  1.16      0.015     0.006     0.000     0.010     1748   GraphQL::Execution::FieldResult#initialize
  1.05      0.014     0.005     0.000     0.009     1748   GraphQL::Schema::MiddlewareChain#initialize
  0.69      0.006     0.003     0.000     0.002     1833   Kernel#initialize_dup
  0.46      0.002     0.002     0.000     0.000     1768   Array#initialize_copy
  0.30      0.001     0.001     0.000     0.000      419   GraphQL::Execution::SelectionResult#initialize
  0.28      0.001     0.001     0.000     0.000      466   Hash#initialize
  0.17      0.010     0.001     0.000     0.009       92   GraphQL::InternalRepresentation::Selection#initialize
  0.15      0.002     0.001     0.000     0.001      162   Set#initialize
  0.15      0.001     0.001     0.000     0.000       70   GraphQL::InternalRepresentation::Node#initialize
  0.07      0.001     0.000     0.000     0.001       58   GraphQL::StaticValidation::FieldsWillMerge::FieldDefinitionComparison#initialize
  0.04      0.001     0.000     0.000     0.000       64   GraphQL::Query::Arguments#initialize
  0.01      0.000     0.000     0.000     0.000       11   GraphQL::StaticValidation::FragmentsAreUsed::FragmentInstance#initialize
  0.01      0.000     0.000     0.000     0.000        1   GraphQL::Query#initialize
# ... truncated ...
</code></pre>

<p>Lots of GraphQL internals! That&rsquo;s good news though: those are within scope for optimization.</p>

<p><code>MiddlewareChain</code> was ripe for a refactor. In the old implementation, <em>each</em> field resolution created a middleware chain, then used it and discarded it. However, this was a waste of objects. Middlewares don&rsquo;t change during query execution, so we should be able to reuse the same list of middlewares for each field.</p>

<p>This required a bit of refactoring, since the old implementation modified the array (with <code>shift</code>) as it worked through middlewares. In the end, this improvement was added in <a href="https://github.com/rmosolgo/graphql-ruby/pull/462/commits/5549e0cff288a9aecd676603cbb62628a34b4ec8"><code>5549e0cf</code></a>. As a bonus, the number of created <code>Array</code>s (shown by <code>Array#initialize_copy</code>) also declined tremendously since they were used for <code>MiddlewareChain</code>&rsquo;s internal state. Also, calls to <code>Array#shift</code> were removed, since the array was no longer modified:</p>

<pre><code class="text">~/code/graphql $ cat 130_prof.txt | grep shift
  0.61      0.003     0.003     0.000     0.000     3496   Array#shift
~/code/graphql $ cat 150_prof.txt | grep shift
~/code/graphql $
</code></pre>

<p>🎉 !</p>

<p>The number <code>FieldResult</code> objects was also reduced. <code>FieldResult</code> is used for execution bookkeeping in some edge cases, but is often unneeded. So, we could optimize by removing the <code>FieldResult</code> object when we had a plain value (and therefore no bookkeeping was needed): <a href="https://github.com/rmosolgo/graphql-ruby/commit/07cbfa89031819d3886f220de8256e83ff59f298"><code>07cbfa89</code></a></p>

<p>A very modest optimization was also applied to <code>GraphQL::Arguments</code>, reusing the same object for empty argument lists (<a href="https://github.com/rmosolgo/graphql-ruby/pull/500/commits/4b07c9b46345144c7d88e429e7b55e09b0615517"><code>4b07c9b4</code></a>) and reusing the argument default values on a field-level basis (<a href="https://github.com/rmosolgo/graphql-ruby/pull/500/commits/4956149df0a4ab8a449679bcd9af20b3dad72585"><code>4956149d</code></a>).</p>

<h2>Avoid Duplicate Calculations</h2>

<p>Some elements of a GraphQL schema don&rsquo;t change during execution. As long as this holds true, we can cache the results of some calculations and avoid recalculating them.</p>

<p>A simple caching approach is to use a hash whose keys are the inputs and whose values are the cached outputs:</p>

<pre><code class="ruby"># Read-through cache for summing two numbers
#
# The first layer of the cache is the left-hand number:
read_through_sum = Hash.new do |hash1, left_num|
  # The second layer of the cache is the right-hand number:
  hash1[num1] = Hash.new do |hash2, right_num|

    # And finally, the result is stored as a value in the second hash:
    puts "Adding #{left_num} + #{right_num}"
    hash2[right_num] = left_num + right_num
  end
end

read_through_sum[1][2]
# "Adding 1 + 2"
# =&gt; 3

read_through_sum[1][2]
# =&gt; 3
</code></pre>

<p>The first lookup printed a message and returned a value but the second lookup did <em>not</em> print a value. This is because the block wasn&rsquo;t called. Instead, the cached value was returned immediately.</p>

<p>This approach was applied aggressively to <code>GraphQL::Schema::Warden</code>, an object which manages schema visibility on a query-by-query basis. Since the visibility of a schema member would remain constant during the query, we could cache the results of visibility checks: first <a href="https://github.com/rmosolgo/graphql-ruby/pull/462/commits/1a28b10494bf508519f8f9b4a1a589c458837cf7"><code>1a28b104</code></a>, then <a href="https://github.com/rmosolgo/graphql-ruby/pull/462/commits/27b36e89ca24b1dc8ec3e2d27612a6fb99039e54"><code>27b36e89</code></a>.</p>

<p>This was also applied to field lookup in <a href="https://github.com/rmosolgo/graphql-ruby/pull/402/commits/133ed1b1e0577df1db222a892d8afd95082c6d33"><code>133ed1b1e</code></a> and to <code>lazy_resolve</code> handler lookup in <a href="https://github.com/rmosolgo/graphql-ruby/pull/402/commits/283fc19d72eb9890ea6254f7fc79600f3f0bfbeb"><code>283fc19d</code></a>.</p>

<h2>Use <code>yield</code> Instead of <code>&amp;block</code></h2>

<p>Due to the implementation of Ruby&rsquo;s VM, calling a block with <a href="https://github.com/JuanitoFatas/fast-ruby#proccall-and-block-arguments-vs-yieldcode"><code>yield</code> is much faster than <code>block.call</code></a>. <code>@theorygeek</code> migrated <code>MiddlewareChain</code> to use that approach instead in <a href="https://github.com/rmosolgo/graphql-ruby/pull/462/commits/517cec3477097ddb05db0e02b6752be552d2e3dd"><code>517cec34</code></a>.</p>

<h2>Remove Overhead from Lazy Definition API (warning: terrible hack)</h2>

<p>In order to handle circular definitions, graphql-ruby&rsquo;s <code>.define { ... }</code> blocks aren&rsquo;t executed immediately. Instead, they&rsquo;re stored and evaluated only when a definition-dependent value is required. To achieve this, all definition-dependent methods were preceeded by a call to <code>ensure_defined</code>.</p>

<p>Maybe you remember that method from the <em>very top</em> of the profiler output above:</p>

<pre><code class="text"> %self      total      self      wait     child     calls  name
  4.60      0.074     0.022     0.000     0.052     6893  *Class#new
  3.99      0.019     0.019     0.000     0.000     8715  *GraphQL::Define::InstanceDefinable#ensure_defined
</code></pre>

<p>A fact about <code>GraphQL::Schema</code> is that, by the time it is defined, <em>all</em> lazy definitions have been executed. This means that during query execution, calling <code>ensure_defined</code> is <em>always</em> a waste!</p>

<p>I found a way to remove the overhead, but it was a huge hack. It works like this:</p>

<p>When a definition is added (with <code>.define</code>):</p>

<ul>
<li>store the definition block for later</li>
<li><p>find each definition-dependent method definition on the defined object and gather them into an array:</p>

<pre><code class="ruby">@pending_methods = method_names.map { |n| self.class.instance_method(n) }
</code></pre></li>
<li><em>replace</em> those methods with dummy methods which:

<ul>
<li>call <code>ensure_defined</code></li>
<li>re-apply all <code>@pending_methods</code>, overriding the dummy methods</li>
<li>call the <em>real</em> method (which was just re-applied)</li>
</ul>
</li>
</ul>


<p>This way, subsequent calls to definition-dependent methods <em>don&rsquo;t</em> call <code>ensure_defined</code>. <code>ensure_defined</code> removed itself from the class definition after its work was done!</p>

<p>You can see the whole hack in <a href="https://github.com/rmosolgo/graphql-ruby/pull/483/commits/18d73a58314cab96c28a9861506b6ad18c8df3aa"><code>18d73a58</code></a>. For all my teasing, this is something that makes Ruby so powerful: if you can imagine it, you can code it!</p>

<h2>The Final Product</h2>

<p>Two minor releases later, the profile output is looking better! Here&rsquo;s the output on master:</p>

<pre><code class="text">Thread ID: 70178713115080
Fiber ID: 70178720382840
Total: 0.310395
Sort by: self_time

 %self      total      self      wait     child     calls  name
  4.06      0.013     0.013     0.000     0.000     7644   Kernel#hash
  2.93      0.021     0.009     0.000     0.012     2917  *Class#new
  2.89      0.009     0.009     0.000     0.000     4184   GraphQL::Query::Context::FieldResolutionContext#query
  2.74      0.009     0.009     0.000     0.000    13542   Module#===
  2.60      0.008     0.008     0.000     0.000     1960   GraphQL::Query::Context::FieldResolutionContext#initialize
  2.27      0.013     0.007     0.000     0.006     1748   GraphQL::Query#arguments_for
  2.25      0.010     0.007     0.000     0.003     7523   Kernel#===
  2.14      0.022     0.007     0.000     0.015     1959   GraphQL::Query::Context::FieldResolutionContext#spawn
  2.09      0.007     0.007     0.000     0.000     8260   Kernel#is_a?
  1.87      0.039     0.006     0.000     0.033     1748   GraphQL::Schema::RescueMiddleware#call
  1.75      0.013     0.005     0.000     0.008     1748   GraphQL::Execution::Lazy::LazyMethodMap#get
  1.69      0.005     0.005     0.000     0.000     2259   Kernel#class
  1.68      0.044     0.005     0.000     0.039     3496  *GraphQL::Schema::MiddlewareChain#invoke_core
  1.33      0.004     0.004     0.000     0.000     1747   GraphQL::Query::Context::FieldResolutionContext#schema
  1.31      0.029     0.004     0.000     0.025     1748   &lt;Module::GraphQL::Execution::Execute::FieldResolveStep&gt;#call
  1.20      0.004     0.004     0.000     0.000     1748   GraphQL::Execution::SelectionResult#set
  1.15      0.048     0.004     0.000     0.044     1748   GraphQL::Schema::MiddlewareChain#invoke
  1.14      0.017     0.004     0.000     0.013     1748   GraphQL::Schema#lazy_method_name
  1.07      0.004     0.003     0.000     0.001     1044   Kernel#public_send
  1.05      0.020     0.003     0.000     0.017     1748   GraphQL::Schema#lazy?
  1.02      0.004     0.003     0.000     0.000     1806   GraphQL::InternalRepresentation::Node#definition
</code></pre>

<p>Here are the wins:</p>

<ul>
<li>Object allocations reduced by 58%</li>
<li>Method calls to gem code and Ruby built-ins reduced by &hellip; a lot!</li>
<li>Calls to <code>ensure_defined</code> reduced by 100% 😆</li>
</ul>


<p>And, as shown in the benchmark above, 1.7x faster query execution!</p>

<p>There&rsquo;s one caveat: these optimization apply to the GraphQL runtime <em>only</em>. <em>Real</em> GraphQL performance depends on more than that. It includes application-specific details like database access, remote API calls and application code performance.</p>
]]></content>
  </entry>
  
</feed>
